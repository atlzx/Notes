# JDBC

## 一、JDBC概述

+ `JDBC`是`Java`官方提供规范接口，各数据库厂商根据接口来实现的一种技术规范
  + `JDBC`使得`Java`能够以相同的方式来连接不同的数据库来实现操作

---

## 二、核心api

### （一）基本步骤

+ 首先，我们需要知道`JDBC`需要用到的类:
  + `DriverManager`
  + `Connection`
  + `Statement`
  + `PreparedStatement`
  + `ResultSet`

1. 注册驱动
2. 创建连接
3. 创建`Statement`对象
4. 执行`SQL`语句，得到`ResultSet`对象
5. 解析结果
6. 释放资源(连接、`statement`、`resultSet`对象)

+ 常用方法

|归属|方法|参数|作用|返回值|返回值类型|抛出异常类型|备注|样例|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|`Class`|`forName(String classPath)`|`classPath`:想加载的类的全类名路径|加载类|`Class`对象|`Class`|`ClassNotFoundException`|无|[样例1](../源码/Java/JDBC/src/statement/LinkDataBaseSample1.java)
|`DriverManager`|`public static registerDriver(Driver driver)`|`driver`:驱动对象,全类名为`java.mysql.cj.jdbc.Driver`(JDK8以下去掉cj)|注册驱动|无返回值|`void`|`SQLExceotion`|**该方法在执行时实际上会注册两次驱动**|^|
|^|`public static getConnection(String url,String user,String password)`|`url`:`MySQL`的具体路径和配置<br>`user`:用户名<br>`password`:密码|得到连接对象|连接对象|`Connection`|^|无|^|
|`Connection`|`createStatement()`|无参|创建一个`Statement`对象|`Statement`对象|`Statement`|^|无|^|
|^|`prepareStatement(String sql)`|`sql`:待执行的`sql`语句|创建一个`PreparedStatement`对象|`PreparedStatement`对象|`PreparedStatement`|^|无|[样例2](../源码/Java/JDBC/src/statement/PrepareStatementSample.java)|
|^|`prepareStatement(String sql,int autoGeneratedKeys)`|`sql`:待执行的`sql`语句<br>`autoGeneratedKeys`:表示是否支持主键回显|创建一个`PreparedStatement`对象|`PreparedStatement`对象|`PreparedStatement`|^|无|[样例3](../源码/Java/JDBC/src/expand/Test1.java)|
|^|`setAutoCommit(boolean autoCommit)`|`autoCommit`:是否自动提交|设置是否自动提交，默认是|无返回值|`void`|^|无|[样例4](../源码/Java/JDBC/src/bank/BankService.java)|
|^|`commit()`|无参|事务提交|无返回值|`void`|^|提交后，才会真正使数据库发生变化|^|
|^|`rollback()`|无参|事务回滚|无返回值|`void`|^|无|^|
|`Statement`|`executeQuery(String sql)`|`sql`:待执行的`sql`查询语句|执行查询语句|查询结果集对象|`ResultSet`|^|无|[样例1](../源码/Java/JDBC/src/statement/LinkDataBaseSample1.java)|
|^|`executeUpdate(String sql)`|^|执行非查询语句|返回更改的行数，如果是不改变行的操作，返回0|`int`|^|无|^|
|`PreparedStatement`|`executeQuery()`|无参|执行查询语句|返回查询结果集|`ResultSet`|`SQLException`|无|[样例2](../源码/Java/JDBC/src/statement/PrepareStatementSample.java)|
|^|`executeUpdate()`|无参|执行非查询语句|返回更改的行数，如果是不改变行的操作，返回0|`int`|^|无|^|
|^|`executeBatch()`|无参|执行批量操作|返回表示更改的行数的数组，若数组某元素值为负数，那么说明该操作出现了问题|`int[]`|^|无|[样例3](../源码/Java/JDBC/src/expand/Test1.java)
|^|`addBatch()`|无参|批量装载数据|`void`|无返回值|^|无|^|
|^|`setObject(int index,Object obj)`|`index`:插入的占位符位置，从1开始<br>`obj`:各列的值|给占位符赋值|`void`|无返回值|^|无|^|
|^|`getMetaData()`|无参|得到游标指向的行的各列的值的集合|游标指向的行的各列的值的集合|`ResultSetMetaData`|^|无|^|
|`ResultSet`|`next()`|无参|结果集指针下移一位|布尔值|`boolean`|^|无|[样例1](../源码/Java/JDBC/src/statement/LinkDataBaseSample1.java)|
|^|`getXxx({String columnLabel \| int columnIndex})`|`columnLabel`:字段名<br>`columnIndex`:查询结果从左至右的次序，从1开始|得到游标所在行的指定字段的具体数据类型值|对应值|具体指定的类型|^|无|^|


---

### （二）注册驱动

+ 我们可以使用`DriverManager`类来注册驱动:

~~~java
    DriverManager.registerDriver(new Driver());
~~~

+ 但这种方式会导致注册两次驱动，原因是`Driver`内部的静态代码块已经执行了一次注册驱动的操作:

~~~java
    public class Driver extends NonRegisteringDriver implements java.sql.Driver {
        public Driver() throws SQLException {
        }
        /*
            下面的静态代码块已经执行了一次注册驱动的操作
        */
        static {
            try {
                DriverManager.registerDriver(new Driver());
            } catch (SQLException var1) {
                throw new RuntimeException("Can't register driver!");
            }
        }
    }
~~~

+ 静态代码块执行的条件是类被加载，类被加载可以通过以下情况触发:
  + 使用`new`关键字新建实例对象
  + 调用静态变量或静态方法
  + 反射
  + `main`函数执行
  + 子类调用会触发父类的静态代码块
  + 接口在`JDK1.8`新特性:调用默认方法
+ 因此，为了解决重复注册驱动的问题，可以使用`Class.forName("com.mysql.cj.jdbc.Driver");`的方式来加载类，即使用反射的方式来加载类以注册驱动

---

### （三）创建连接

+ `DriverManager`的静态方法`getConnection`方法专门用来创建连接，它有三个重载方法:
  + `getConnection(String url,String user,String password)`
  + `getConnection(String url,Properties info)`
  + `getConnection(String url)`
  + 这三个方法都返回`Connection`对象
+ `url`参数用来告知`MySQL`连接的路径和一些配置信息
  + 它的具体语法是:`jdbc:{mysql\|oracle}://{ip地址\|主机名}:端口号/数据库名[?key1=value1&key2=value2&....(可选信息)]`
  + 如果使用的是主机并且`MySQL`服务占用的端口号是3306端口，那么此时可以简写为`jdbc:{mysql\|oracle}:///数据库名[?key1=value1&key2=value2&....(可选信息)]`
  + 例:`jdbc:mysql://localhost:3306/atguigudb`，或简写为`jdbc:mysql:///atguigudb`
  + 可用的配置信息包括:`serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf8&useSSL=true`
    + 其中时区配置信息(`serverTimezone`)在`jdbc8.0.25`版本后会自动识别，不用再手动配置
    + 后面的配置信息在`jdbc 8`版本后就默认使用`utf-8`解码了，因此不需要再额外配置
  + 如果是一个参数的`getConnection`方法，它的配置项后必须加上`?user=用户名&password=密码`，例:`jdbc:mysql://localhost:3306/atguigudb?user=root&password=123456`
+ `user`参数用来提供用户名
+ `password`参数用来提供密码
+ `info`参数用来提供**至少承载着用户名和密码的键值对**，`Properties`对象可以连接着一个`properties`文件，也可以我们手动创建一个对象，然后用`put`方法往里面塞键值对，因为它继承自`HashTable`类，属于`Map`

|方法|参数|作用|返回值|返回值类型|抛出异常类型|备注|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|`createStatement()`|无参|创建一个`Statement`对象|`Statement`对象|`Statement`|`SQLException`|无|
|`prepareStatement(String sql)`|`sql`:待执行的`sql`语句|创建一个`PreparedStatement`对象|`PreparedStatement`对象|`PreparedStatement`|^|无|
|`prepareStatement(String sql,int autoGeneratedKeys)`|`sql`:待执行的`sql`语句<br>`autoGeneratedKeys`:表示是否支持主键回显|创建一个`PreparedStatement`对象|`PreparedStatement`对象|`PreparedStatement`|^|无|
|`setAutoCommit(boolean autoCommit)`|`autoCommit`:是否自动提交|设置是否自动提交，默认是|无返回值|`void`|^|无|
|`commit()`|无参|事务提交|无返回值|`void`|^|无|
|`rollback()`|无参|事务回滚|无返回值|`void`|^|无|^|


---

### （四）创建Statement对象

#### ①Statement

+ 使用`Connection`对象的`createStatement()`方法来创建一个`Statement`对象
+ `Statement`对象是用来执行`sql`语句的对象
  + `executeQuery`方法**专门用来执行查询语句**
  + `executeUpdate`方法**可以执行除查询语句之外的`sql`语句**
  + **存在`SQL注入`的风险**

---

#### ②PreparedStatement

+ `PreparedStatement`可以避免`SQL`语句的拼接，并规避`SQL`注入的风险
+ 使用`Connection`对象的`prepareStatement(String sql)`方法来创建一个`PreparedStatement`对象
  + `sql`参数可以使用占位符来确认`SQL`语句的格式，例:`select * from 表名 where user_name = ? and password = ?`

|方法|参数|作用|返回值|返回值类型|抛出异常类型|备注|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|`executeQuery()`|无参|执行查询语句|返回查询结果集|`ResultSet`|`SQLException`|无|
|`executeUpdate()`|无参|执行非查询语句|返回更改的行数，如果是不改变行的操作，返回0|`int`|^|无|
|`getMetaData()`|无参|得到游标指向的行的各列的值的集合|游标指向的行的各列的值的集合|`ResultSetMetaData`|^|无|
|`setObject(int index,Object obj)`|`index`:插入的占位符位置，从1开始<br>`obj`:各列的值|给占位符赋值|`void`|无返回值|^|无|
|`setXxx(int index,T value)`|`index`:插入的占位符位置，从1开始<br>`value`:对应类型的值|给占位符赋值|^|^|^|无|
|`getGeneratedKeys()`|无参|得到当前自增的主键|`ResultSet`对象|`ResultSet`|^|无|

+ `ResultSetMetaData`有如下方法:

|方法|参数|作用|返回值|返回值类型|抛出异常类型|备注|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|`getColumnCount()`|无参|得到列的数量|数值|`int`|`SQLException`|无|
|`getColumnLabel(int cloumnIndex)`|`columnIndex`:从左至右的次序，从1开始|得到对应次序的列的别名，如果没有别名返回列名|列名|`String`|^|无|
|`getColumnName(int columnIndex)`|`columnIndex`:从左至右的次序，从1开始|得到对应次序的列的名称，无法识别别名|列名|`String`|^|无|


---

### （五）ResultSet对象

+ `ResultSet`对象用来存放查询结果
  + 对象可以调用游标来读取查询结果内指定行的数据，游标最开始位于第一行上面的位置
  + 对象可以使用`getXxx`方法来读取当前游标指向行的指定字段的数据

|分类|方法|参数|作用|返回值|返回值类型|抛出异常类型|备注|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|游标操作|`next()`|无参|游标下移一行|成功移动返回`true`，反之返回`false`|`boolean`|`SQLException`|无|
|^|`previous()`|无参|游标上移一行|^|^|^|无|
|^|`beforeFirst()`|无参|游标移动到第一行上面|^|^|^|无|
|^|`afterLast()`|无参|游标移动到最后一行下面|^|^|^|无|
|^|`first()`|无参|游标移到第一行|^|^|^|无|
|^|`last()`|无参|游标移到最后一行|^|^|^|无|
|^|`absolute(int row)`|`row`:移动的行数，负数向上移，正数向下移|游标移动到相对于起点的指定行数|^|^|^|无|
|^|`relative(int row)`|^|游标|移动到相对于当前位置的指定行数^|^|^|无|
|^|`isFirst()`|无参|判断游标是否指向第一行|是返回`true`,不是返回`false`|^|^|无|
|^|`isLast()`|无参|判断游标是否指向最后一行|^|^|^|无|
|^|`getRow()`|无参|得到游标当前指向的行|一般会返回行数，但如果游标未在有效行，返回0|`int`|^|无|
|读取数据|`getXxx({String columnLabel \| int columnIndex})`|`columnLabel`:字段名<br>`columnIndex`:查询结果从左至右的次序，从1开始|得到游标所在行的指定字段的具体数据类型值|对应值|具体指定的类型|^|无|^|

+ [样例](../源码/Java/JDBC/src/statement/PrepareStatementSample.java)

---

## 三、扩展

### （一）主键回显

+ 有时我们想得到自增的主键的值，此时我们就可以向`prepareStatement`传入第二个参数:`Statement.RETURN_GENERATED_KEYS`，用来设置支持主键回显
+ 设置后，在执行完毕`SQL`语句后，便可以通过`getGeneratedKeys`方法得到自增的主键了
+ [样例](../源码/Java/JDBC/src/expand/Test1.java)

---

### （二）事务处理

+ 在`SQL`处理出现异常时，我们希望它恢复到之前的状态，因此我们需要使用事务处理来执行提交与回滚操作
  + `Connection`对象提供了这些方法
  + `setAutoCommit(boolean autoCommit)`用来设置操作是否自动提交
  + `commit()`方法用来手动提交
  + `rollback()`用来手动进行回滚操作
  + `commit()和rollback()`方法通常与`try-catch`语句搭配使用
+ [样例](../源码/Java/JDBC/src/bank/BankService.java)

---

### （三）批量插入数据

+ 我们可以通过在建立连接时传入可选参数`rewriteBatchedStatements=true`来支持`PreparedStatement`对象的批量插入操作
  + 使用`PreparedStatement`对象的`addBatch`方法用来批量装载数据
  + 使用`PreparedStatement`对象的`executeBatch`方法用来专门执行批量插入的语句
    + `executeBatch`方法会返回一个`int[]`类型的数组，数组内的元素索引与执行命令的操作次序是一致的。
    + 如果数组元素的值是正数，表明该操作影响的行数
    + 如果数组元素的值是0，表名该操作执行成功了，但为影响到任何行
    + 如果数组元素的值是-2，说明为常数`Statement.SUCCESS_NO_INFO`，它表示执行成功了，但是影响的行数无法统计
    + 如果数组元素的值是-3,说明为常数`Statement.EXECUTE_FAILED`，它表示执行失败
+ [样例](../源码/Java/JDBC/src/expand/Test1.java)

---

### （四）Druid连接池

+ 我们执行`JDBC`操作主要有三个时间花销:
  + 建立连接
  + 执行语句
  + 关闭连接
+ 但是，如果处理的事务变多，单纯建立和关闭连接的时间占比就会变得很长，导致效率降低
+ `Druid`连接池用来专门管理与数据库的连接事务
  + 可以通过硬编码，即直接将配置写在代码中的方式来配置连接池
  + 也可以通过软编码:即通过`.properties`文件，使用`Properties`对象读取文件内容的方式来配置连接池

|归属|方法|参数|作用|返回值|返回值类型|抛出异常类型|备注|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|`DruidDataSource`|`DruidDataSource()`|无参|构造器|`DruidDataSource`对象|`DruidDataSource`|无|无|
|^|`setUrl(String url)`|`url`:数据库连接路径|设置数据库连接路径|无返回值|`void`|无|无|
|^|`setDriverClassName(String className)`|`className`:设置驱动的全类名路径|设置驱动类全路径|无返回值|`void`|无|无|
|^|`setUsername(String userName)`|`userName`:用户名|设置登录用户名|无返回值|`void`|无|无|
|^|`setPassword(String pwd)`|`pwd`:密码|设置密码|无返回值|`void`|无|无|
|^|`setInitialSize(int size)`|`size`:初始连接数量|设置连接池内的初始连接数量|无返回值|`void`|无|无|
|^|`setMaxActive(int size)`|`size`:最大连接数量|设置连接池内的最大连接数量|无返回值|`void`|无|无|
|^|`getConnection()`|无参|得到连接池内的一个连接|连接对象|`DruidPooledConnection`|`SQLException`|无|

|配置项|数据类型|作用|默认值|是否必须|备注|
|:---:|:---:|:---:|:---:|:---:|:---:|
|`driverClassName`|`String`|驱动的全类名路径|需要自行指定|是|无|
|`url`|^|数据库连接路径|^|^|无|
|`username`|^|用户名|^|^|无|
|`password`|^|密码|^|^|无|
|`initialSize`|`int`|连接池初始化连接数量|0|否|无|
|`maxActive`|^|连接池最大连接数量|8|^|无|
|`minIdle`|^|连接池最小连接数量|无|^|无|
|`name`|`String`|指定数据源名称，便于区分|无|^|无|
|`maxWait`|`int`|获取连接池内连接的最大等待时间（毫秒）|无|^|配置后会缺省启用公平锁，开发效率会有所下降|
|`poolPreparedStatements`|`boolean`|设置是否启用`PreparedStatement`缓存|`false`|^|对支持游标的数据库性能提升巨大。`Oracle`建议开启，`MySQL`建议关闭|
|`maxOpenPreparedStatements`|`int`|设置最大缓存数量|-1|^|无|
|`validationQuery`|查询语句|设置检测连接是否有效的`select`查询语句|无|^|如果没有配置，`testOnBorrow`、`testOnReturn`和`testWhileIdle`会失效|
|`testOnBorrow`|`boolean`|是否使用`select`语句检查连接是否有效|`true`|^|使用它会降低性能|
|`testOnReturn`|^|是否在回收连接时使用`select`语句检查连接是否有效|`true`|^|无|
|`testWhileIdle`|^|申请连接的时候检测，如果空闲时间大于`timeBetweenEvictionRunsMillis`，执行`select`语句检测连接是否有效|`true`|^|无|
|`timeBetweenEvictionRunsMillis`|`int`|1.`Destroy`线程会检测连接的间隔时间（单位毫秒）<br>2.`testWhileIdle`检测的依据|无|^|无|
|`connectionInitSqls`|`SQL`语句|连接初始化时执行的`SQL`语句|无|^|无|

+ [样例](../源码/Java/JDBC/src/druid/DruidSample.java)

---

## 四、工具类封装

### （一）JDBCUtils

+ 为了简化应用层的调用，我们需要为简单的数据库连接和释放操作封装在一个工具类中
  + 为了方便事务的操作，在应用层和`DAO`层在一个事务内的`Connection`对象应该是一致的,`Java.lang.ThreadLocal`能够帮助我们在一个线程内的不同方法之间实现共享变量
  + 为了方便调用，`JDBCUtils`工具类内的方法应该是静态方法
  + 线程池应作为类的属性存在
  + 提供连接的获取和释放方法

~~~java

  import com.alibaba.druid.pool.DruidDataSourceFactory;

  import javax.sql.DataSource;
  import java.io.InputStream;
  import java.sql.Connection;
  import java.sql.SQLException;
  import java.util.Properties;

  public class JDBCUtils {
      /*
          JDBCUtils有两个属性:dataSource和threadLocal
              dataSource是数据库的连接池对象
              threadLocal是数据库的本地线程对象，它可以承载一个线程的不同方法都能共享的变量
      */
      private static DataSource dataSource;
      private static ThreadLocal<Connection> threadLocal;

      static {
          // 使用软编码实现线程池初始化
          Properties properties = new Properties();
          InputStream input = JDBCUtils.class.getResourceAsStream("info.properties");
          try {
              properties.load(input);
              dataSource = DruidDataSourceFactory.createDataSource(properties);
              threadLocal = new ThreadLocal<>();
          } catch (Exception e) {
              throw new RuntimeException("初始化JDBCUtils工具类属性出错");
          }
      }

      public static Connection getConnection() throws SQLException {

          Connection con=threadLocal.get();

          if (con == null) {
              con=dataSource.getConnection();
              threadLocal.set(con);
          }
          return con;
      }

      public static void releaseConnection() throws SQLException{
          Connection con = threadLocal.get();
          // 判断连接是否为true且通过判断是否为自动提交来判断是否在执行事务
          if(con!=null){
              con.setAutoCommit(true);  // 重新设置自动提交
              con.close();  // 回收连接
              threadLocal.remove();  // 把Connection对象从threadLocal中移除，表示事务结束
          }
      }
  }
~~~


---

### ②BaseDao

+ 一般的，我们会为各`Dao`层的类创建一个公共父类，即`BaseDao`
  + 它是所有`Dao`实现类的公共父类，即所有`Dao`类都继承于它
  + 它提供基本的数据执行方法，即`executeUpdate`与`executeQuery`
  + `executeQuery`为了保证其灵活性和通用性，需要使用反射与泛型来编写
  + 我们会为每一个数据库表都创建一个对应类，使查询结果的每行结果都作为该类的一个实例对象存在

~~~java
  import java.lang.reflect.Constructor;
  import java.lang.reflect.Field;
  import java.lang.reflect.InvocationTargetException;
  import java.sql.Connection;
  import java.sql.PreparedStatement;
  import java.sql.ResultSet;
  import java.sql.SQLException;
  import java.util.ArrayList;
  import java.util.List;

  public class BaseDao {
      public int executeUpdate(String sql,Object ...params) throws SQLException {
          Connection con = JDBCUtils.getConnection();
          PreparedStatement preSta = con.prepareStatement(sql);
          if(params!=null&&params.length>0){
              for(int i=1;i<= params.length;i++){
                  preSta.setObject(i,params[i-1]);
              }
          }
          int rows=preSta.executeUpdate();
          preSta.close();
          return rows;
      }

      // 使用泛型和反射，来灵活的接收各个类的查询情况
      public <T> List<T> executeQuery(Class<T> clazz, String sql, Object ...params) throws SQLException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
          Connection con = JDBCUtils.getConnection();
          PreparedStatement preSta = con.prepareStatement(sql);
          List<T> list=new ArrayList<>();
          if(params!=null&&params.length>0){
              for (int i = 1; i <= params.length; i++) {
                  preSta.setObject(i,params[i-1]);
              }
          }
          
          ResultSet rs = preSta.executeQuery();
          while(rs.next()){
              Constructor<T> constructor = clazz.getDeclaredConstructor();  // 得到对应类对象的声明的空参构造器
              T instance = constructor.newInstance();  // 创建一个空参构造器实例
              Field[] fields = clazz.getDeclaredFields();  // 得到对应类对象的声明的属性数组
              for (int i = 0; i < fields.length; i++) {
                  fields[i].setAccessible(true);  // 设置属性可修改，打破private修饰符的限制
                  fields[i].set(instance,rs.getObject(i+1));  // 给对应实例对象的对应属性赋值
              }
              list.add(instance);  // 将结果添加进列表内
          }
          // 释放资源
          rs.close();
          preSta.close();
          return list;

      }
  }

~~~


---


