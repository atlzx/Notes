# 问题汇总

## 一、IDEA问题

### （一）idea配置tomcat

1.  可以在`设置(settings)->编辑(editor)->文件编码(File Encodings)`分别为`全局编码(Global Encoding)`、`项目编码(Project Encoding)`、`属性文件的默认编码(Default > Encoding for Properties Files)`设置 全局、项目和`properties`文件的编码类型
2.  在`设置(settings) -> 构建、执行、部署(Build,Execution,Deployment) -> 应用程序服务器(Application Servers) `下可以添加服务器(`tomcat`等)
3.  在模块的`打开模块设置(Project Structure) -> 项目设置(Modules) -> 选择模块 -> 依赖(Dependencies)`可以添加模块所依赖的库(`tomcat`库等)，这些库不能被`Java`库默认提供，因此需要导入
4.  点击项目再按`Shift+Shift`，搜索`框架(frame)`，可以找到`添加框架支持(Add Framework Support)`来添加框架(`Web Application`)支持，该设置需要先添加
5.  在运行按钮边`编辑配置(Edit Configurations) -> 点击加号 -> 选择tomcat 本地(Local) `可以配置`tomcat`的运行配置，如`应用程序服务器(Application Server)`可以选择`tomcat`的版本，`打开浏览器(Open Browser)`可以选择运行时**默认打开的浏览器**、`部署(deployment)`可以添加**运行时具体运行哪个项目**,(`工件(Artifacts)`),`应用程序上下文(Application Context)`设置打开该项目使用的**上下文路径**


---


## 二、tomcat问题

### （一）项目乱码

> 1. `tomcat`打印的日志乱码时，在其**根目录的`conf`文件夹里的`logging.properties`中**修改编码为`GBK`，原因是编码时`tomcat`默认打印日志的编码为`UTF-8`，但操作系统对日志进行解码输出时默认使用操作系统本地的解码,中国地区一般为`GBK`编码，因此**需要让`tomcat`去适应操作系统的解码方式**，所以要将其编码方式设置为`GBK`
> 2. 打开项目的`html`文件乱码时，可能为`html`编码方式与`<meta charset="xxx">`中设置的解码方式不一致，**由于`UTF-8`编码是`html5`文档的唯一有效编码，因此不建议修改`charset`属性**，可以通过修改该文档的编码格式来使其与`charset`属性值保持一致。如果无法修改再考虑修改`charset`属性
> 3. 使用`System.out.println()`方法输出乱码时，可能为两个原因:**1.`idea`在将`java`文件编译为`class`文件时解码和编码不一致2.`JVM`加载`class`类时解码与编码方式不一致**。第一种原因一般不会出现，**因为`idea`比较智能，他会自动识别`java`文件的编码格式并进行编译**。第二种原因则需要**修改`tomcat`运行配置的`虚拟机选项(VM options)`，添加`-Dfile.encoding=UTF-8`**，其中字符集按需要修改
> 4. `get`请求乱码:**在`tomcat根目录 -> conf -> logging.properties`中为`Connector`标签添加属性`URIEncoding`属性(默认编码为`UTF-8`)中并为其设置合适的属性值**，产生乱码的原因是`get`请求通过`URI`进行传递，其使用的编码(即`meta`标签的`charset`属性值)与`tomcat`默认接收信息时的解码方式不一致
> 5. `post`请求乱码:`post`请求不通过`url`进行参数的数据的传递，因此无法通过设置`URIEncoding`属性来解决乱码问题，可以设置`request.setCharacterEncoding("UTF-8")`来设置`tomcat`接收请求体时使用什么方式进行解码
> 6. 响应体乱码问题:
>    1. 可以设置`response.setCharacterEncoding("UTF-8")` 来设置`tomcat`对响应体以什么方式进行编码(**不推荐，因为不同的客户端使用的编码格式可能不同**)
>    2. 可以设置`response.setContentType("text/html;charset=UTF-8")`来**通过响应头的`Content-Type`属性告知客户端响应体的编码格式**

---

### （二）tomcat配置


#### ①tomcat配置

1. `conf`目录下
  + `server.xml`中的`Connector`标签内可以设置`tomcat`的端口号(`port`)、使用的`HTTP`协议(`protocol`)、解码方式(`URIEncoding`,默认为`UTF-8`)
  + `tomcat-user.xml`用于存储`tomcat`用户信息，如`tomcat`用户的用户名和密码，以及用户的角色信息，可以根据其注释添加
  + `web.xml`用于部署描述符文件，它用来**通过服务器告知浏览器其请求的文档类型**，`tomcat`的`web.xml`文件是**所有项目的共享配置文件，它作用于所有部署于`tomcat`的项目**，里面默认包含了:
    1. 文件类型所对应的`Content-Type`属性值
    2. `tomcat`启动时默认构建的`Servlet`类
    3. 打开项目时默认寻找并打开的文件名(一般为`index.jsp、index.html和index.htm`)
    4. `session`的时效(`<session-config> -> <session-timeout>`)
  + `Catalina`中的`localhost`文件夹内可以新建`xxx.xml`文件以不向`tomcat`的`webapp`目录添加项目，而告知`tomcat`应该去哪里寻找该项目，在`xml`文件中写入`<Context path="xxxx" docBase="xxxx" />`以进行配置，`path`是项目启动时的上下文路径，`docBase`是项目在磁盘中的路径
2. `lib`文件夹用于存放`tomcat`运行时所需的**项目`jar`包**，它可以作用于`webapp`下**所有**的项目
  + 
3. `logs`文件夹用于存放`tomcat`运行时的**日志**
  + `logging.properties`用来配置打印时遵循的规则，可以在这里改变编码以应对`tomcat`日志输出乱码
4. `temp`文件夹用于存放`tomcat`的**临时文件**
  + 
5. `webapp`文件夹用于存放`tomcat`的**项目文件**，其中的**每一个文件夹都是一个项目**，可以直接通过`http://localhost:8080/项目路径`在浏览器上呈现项目中的文件
  + 
6. `work`文件夹主要用于存放与`jsp`相关的文件，其运行时生成的文件都放在该文件夹下
  + 
7. `LICENSE`:许可证
8. `NOTICE`:说明文件

---

#### ②web.xml标签配置

|分类|标签|内容描述|标签描述|写入位置|备注|
|:---:|:---:|:---:|:---:|:---:|:---:|
|配置`Servlet`|`servlet`|内部嵌套配置`servlet`的详细标签|配置`servlet`的总标签|应写在`web-app`根标签内|无|
|^|`servlet-name`|对应`servlet`的别名|设置`servlet`别名|可以写在`servlet`、`servlet-mapping`或`filter-mapping`标签内|写在`servlet`和`servlet-mapping`中时表示对应`servlet`的别名<br>写在`filter-mapping`中时表示该别名的`servlet`要经过对应的`filter`过滤检验|
|^|`servlet-mapping`|内部嵌套配置指定`servlet`对应的映射路径的详细标签|配置`servlet`映射关系的总标签|应写在`web-app`根目录内|无|
|^|`servlet-class`|>|告诉`tomcat`要实例化的`servlet`的路径|应写在`servlet`标签内|无|
|^|`url-pattern`|>|客户端提交的路径|应写在`servlet-mapping`或`filter-mapping`标签内|写在`servlet-mapping`中时表示该路径要交给对应别名的`servlet`处理<br>写在`filter-mapping`中表示该路径需要先经过指定别名的`filter`进行过滤检验|
|^|`load-on-startup`|对应`servlet`启动时的优先级,大于`0`的值为启动时就构建,并表示构建时排在第几位，`-1`为请求时再构建，默认为`-1`|设置对应`servlet`何时构建与其构|^建的优先级|写在`servlet`标签内|1.前面几个大于`0`的值已经被`tomcat`默认启动的`servlet`占用了，建议从`5`以后开始写<br>2.数值一致冲突时，`tomcat`会**自动协调**|
|^|`init-param`|内部嵌套配置`ServletConfig`的详细标签|配置`ServletConfig`的总标签|应写在`servlet`标签内|一个`init-param`仅允许有一个键值对|
|^|`context-param`|内部嵌套配置`ServletContext`的详细标签|配置`ServletContext`的总标签|1.应写在`servlet`标签内|一个`context-param`仅允许有一个键值对|
|^|`param-name`|>|设置`ServletConfig`的一个键|应写在`init-param`或`context-param`标签内|无|
|^|`param-value`|>|设置`ServletConfig`的键对应的值|^|无|
|配置`session`|`session-config`|内部嵌套配置`session`的详细标签|配置`session`的总标签|应写在`web-app`根标签内|无|
|^|`session-timeout`|>|设置`session`存在的时间长度(单位:分钟)|写在`session-config`标签内|无|
|配置启动资源|`welcome-file-list`|>|设置项目启动时默认寻找并打开的资源集合|写在`web-app`标签内|该标签可以包含多个`welcome-file`标签|
|^|`welcome-file`|>|设置项目启动时默认寻找并打开的资源|写在`welcome-file-list`标签内|无|
|配置`filter`|`filter`|内部嵌套配置`filter`的详细标签|配置`filter`的总标签|应写在`web-app`根目录内|无|
|^|`filter-name`|过滤器的别名|给过滤器设定别名|应写在`filter`标签内|无|
|^|`filter-class`|对应的`filter`别名的位置|在这里告诉`tomcat`指定`filter`的路径|应写在`filter`标签内|无|
|^|`filter-mapping`|内部嵌套配置指定`filter`对应的映射路径的详细标签|配置`filter`映射关系的总标签|应写在`web-app`根目录内|1.该标签可以包含多个`servlet-name`和`url-pattern`<br>2.**该标签的上下顺序是过滤器执行的先后顺序**|

---

#### ③注解配置

|分类|属性名|描述|属性值|备注|
|:---:|:---:|:---:|:---:|:---:|
|`@WebServlet`|`name`|当前的类的别名|字符串|`servlet-name`|无|
|^|`value`|`urlPatterns`的别名，二者互相影响，用来指定对应`Servlet`类对应的请求映射路径|字符串或`{"xxx","yyy"}`型的数组|注解中仅写有单个路径的前提下，可以只写属性值，不写属性名|
|^|`urlPatterns`|`value`的别名，用来指定对应`Servlet`类对应的请求映射路径|^|^|
|^|`loadOnStartup`|设置该类在`tomcat`启动时的构建优先级|传入数值,`tomcat`会**依据此数值判断是否在容器启动时进行类的实例化，并根据数值协调各个类之间的实例顺序**，`1`为第一个，`2`为第二个...默认值为`-1`，表示**不在容器启动时进行构建**|数值设置一致导致冲突时，`tomcat`会**自动协调**|
|^|`initParams`|为当前`Servlet`配置`ServletConfig`初始化参数|`initParams={@WebInitParam(name="xxxx",value="xxxx",description(可选)="xxxx"),@WebInitParam(...)}`|`initParams`所需的数组内的参数**实际上也是一个类型注解**|
|`@WebFilter`|`filterName`|设置`filter`的别名|字符串|无|
|^|`value`|`urlPatterns`的别名，二者互相影响，用来指定对应`Servlet`类对应的请求映射路径|字符串或`{"xxx","yyy"}`型的数组|注解中仅写有单个路径的前提下，可以只写属性值，不写属性名|
|^|`urlPatterns`|`value`的别名，用来指定对应`Servlet`类对应的请求映射路径|^|^|
|^|`servletNames`|用来指定哪些`Servlet`类在处理请求前交给该`filter`进行过滤|字符串或`{"xxx","yyy"}`型的数组|无|
|^|`initParams`|为当前`filter`配置`FilterConfig`初始化参数|`initParams={@WebInitParam(name="xxxx",value="xxxx",description(可选)="xxxx"),@WebInitParam(...)}`|`initParams`所需的数组内的参数**实际上也是一个类型注解**|

---

#### ④Context.xml配置

+ `Context.xml`文件位于`web`目录下的`META-INF`文件夹内

|分类|标签|内容描述|标签描述|写入位置|备注|
|:---:|:---:|:---:|:---:|:---:|:---:|
|配置`session`|`Manager`|`className`属性用来指定具体类的路径,一般为`org.apache.catalina.session.PersistentManager`<br>`maxIdleSwap`属性指定`session`对象多长时间没有被访问后存入内存,单位为分钟(不确定)|指定`Session`管理器中`Session`数据的**持久化存储方式和存储路径**|根标签`Context`内|无|
|^|`Store`|`className`属性用来指定具体类的路径,一般为`org.apache.catalina.session.FileStore`<br>`directory`属性用来指定`session`存储在磁盘中的路径|配置`session`钝化与活化的路径|写在`Manager`标签内|无|


---

### （三）跨域问题

+ 浏览器有自动保护的机制，它在收到响应时会依次检索响应源与当前服务器的**协议和端口**是否一致，如果不一致，浏览器会认为这是不安全的，便不予处理
+ 为了应对这一问题，我们需要在后端添加如下代码:

~~~java
  import jakarta.servlet.FilterChain;
  import jakarta.servlet.ServletException;
  import jakarta.servlet.http.HttpServletRequest;
  import jakarta.servlet.http.HttpServletResponse;

  import java.io.IOException;
  import jakarta.servlet.*;
  import jakarta.servlet.annotation.WebFilter;

  @WebFilter("/*")
  public class ServletFilter implements Filter {
      @Override
      public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
          HttpServletRequest request = (HttpServletRequest) servletRequest;
          System.out.println(request.getMethod());
          HttpServletResponse response = (HttpServletResponse) servletResponse;
          // 设置允许跨域的请求源，可以设置为*，表示所有请求都可以跨域
          response.setHeader("Access-Control-Allow-Origin", "http://localhost:5173");
          // 设置允许跨域的请求方式，也可以设置为*，表示所有请求方式都可以跨域
          response.setHeader("Access-Control-Allow-Methods", "POST, GET, PUT,OPTIONS, DELETE, HEAD");
          // 设置此次跨域凭证的持续时间，单位为秒，需要使用字符串进行设置
          response.setHeader("Access-Control-Max-Age", "3600");
          // 设置允许跨域的请求头中的属性，可以设置为*，表示请求头随便写，都可以跨域
          response.setHeader("Access-Control-Allow-Headers", "access-control-allow-origin, authority, content-type, version-info, X-Requested-With");
          // 设置跨域需要跨域凭证，该设置需要在前后端都进行设置，设置该项后，后端的session便不会出现一次请求更新一次session的情况了
          response.setHeader("Access-Control-Allow-Credentials", "true");
          // 如果是跨域预检请求,则直接在此响应200业务码
          if(request.getMethod().equalsIgnoreCase("OPTIONS")){
              response.getWriter().write("OK");
              System.out.println("跨域响应");
          }else{
              // 非预检请求,放行即可
              filterChain.doFilter(servletRequest, servletResponse);
          }
      }
  }
~~~

+ 同时，为了不使后端的`session`出现变化，前端在发送请求时需要设置**预检**的相关属性为`true`,这里以`axios`为例:

~~~js
    // axios.post方法第一个参数为url(请求路径),第二个参数为data(向后端发送的数据),第三个属性是config(其他配置)
    axios.post(
        'http://localhost:8080/test',
        {upload:file.file},
        {
            headers:{
                // 设置响应头类型为 multipart/form-data ,说明这是一个文件
                "Content-Type":'multipart/form-data'
            },
            // 设置跨域时进行预检，该设置可以保证后端的session不会一次请求就变化一次
            withCredentials:true
        }
    ).then(
        (response)=>{
            console.log(response);
            if(response.data==='OK'){
                console.log('上传后端成功');
            }
        }
    );
~~~

---

### （四）报错

|报错信息|报错原因|解决方式|备注|
|:---:|:---:|:---:|:---:|
|`java.lang.IllegalStateException: 启动子级时出错 ... ... 名为 [xxx]和 [xxx] 的servlet不能映射为一个url模式(url-pattern) [/ServletA]`|注解与`web.xml`配置同时设置发生冲突|删去其中一个即可解决|无|
|`java.lang.IllegalStateException: 提交响应后无法调用sendRedirect（）`|调用`session.sendRedirect（）`方法后，**程序不会终止而是会继续执行**，当多次执行到该方法时，就会出现异常|不要在重定向后面写东西|无|
|`Operation not allowed after ResultSet closed`|使用同一个`Statement`进行多次`excuteQuery`或`excuteUpdate`时，执行下一次`exceute`时会将上一次`Statement`对象方法所返回的`ResultSet`方法关闭，此时若再次调用该`ResultSet`对象，便会报错|使用不同的`Statement`进行执行|无|
|IDEA无法识别tomcat的jar包|项目未导入tomcat作为其依赖|`打开模块设置->对应模块->依赖->点击+号->选择添加库->将tomcat导入`|无|

~~~java
  // Operation not allowed after ResultSet closed问题示例
  Stament sta=con.createStatement();
  ResultSet rs=sta.executeQuery("select * from xxx");
  sta.executeUpdate("delete * from xxx where xxxx");
  rs.getString("data");  //报错，因为上次的excuteQuery方法产生的ResultSet对象已经被关闭了，原因是sta在之后执行了excuteUpdate方法
  // 应保证在excuteUpdate方法执行前完成需要rs执行的代码，或者创建多个Statement对象以排除互斥
~~~


---

### （五）路径问题

+ 后端的相对路径与前端实际上是一样的
+ 后端的绝对路径也包括项目的上下文路径，但后端可以通过`getServletContext().getContextPath()`来获取当前项目的上下文路径
+ 如果想彻底结局上下文路径问题，需要在`idea`的`tomcat`运行配置内更改其上下文路径为`/`，这样就不需要考虑上下文路径了，因为上下文路径没了

---

### 注意事项

+ 修改`jsp`文件的父文件名时，需要在&nbsp;`点击模块目录->右键->模块设置->facet`中找到`Web资源目录`，修改其路径，使其路径与修改文件名后的路径相同，否则在原`jsp`文件右键不会弹出`运行xxx.jsp`和`调试xxx.jsp`，而且此时启动项目会报错:`404 Not Found`
+ 如果`idea`在更改`css`样式但网页依旧不变，可能是因为浏览器的自动缓存机制。使用`Ctrl+F5`来使浏览器强制刷新网页，或在开发者工具中关闭缓存

---

## 三、Git问题

### （一）乱码问题

+ 由于`Git`默认的`UTF-8`编码与`cmd`跟随系统的`GBK`编码冲突，会导致乱码
+ 此时需要进行一些设置:

~~~bash
  git config --global core.quotepath false
~~~

+ 然后在`Git bash`右击，打开设置，在`Text`中选择`Local`为zh_CN,同时设置`Character set`为UTF-8

---

### （二）报错

~~~bash
# 如果出现SSH相关错误，可以尝试
git config --global http.sslVerify "false"

# 如果连接不上，可以执行下面的一些代码

git config --global --edit  # 查看和修改git的配置项，用于查看设置是否生效
# 为git配置代理
git config --global http.proxy http://127.0.0.1:7890
git config --global https.proxy http://127.0.0.1:7890

~~~

---

## 四、Maven问题

### （一）报错

|报错信息|报错原因|解决方法|备注|
|:---:|:---:|:---:|:---:|
|`Cannot access alimaven (网址) in offline mode`|1.镜像仓库可能要更新了<br>2.idea或Maven的配置不正确<br>3.idea的Maven设置里勾选了`work offline`选项|1.更新镜像<br>2.重新配置<br>3.取消勾选|无|
|`编码 GBK 的不可映射字符`|Maven默认使用操作系统字符集，即GBK进行编译|在pom.xml文件内添加`<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>`以告知Maven使用UTF-8编译项目|无|
|依赖下载失败|1.网络不好<br>2.依赖项的版本错误或依赖项未正确定义<br>3.本地Maven仓库被污染或损坏|1.挂梯子或使用代理<br>2.纠正依赖项<br>3.清除本地 Maven 仓库缓存（lastUpdated 文件），因为只要Maven检测到该缓存，就不会去中央仓库下载|无|
|`Duplicated tag: 'xxxxxx'`|pom.xml内存在重复的标签|删去重复的标签|无|

---

## 五、前端问题

### （一）路径问题


#### ①前端相对路径

+ 浏览器在读取相对路径时，会把当前资源所在路径的目录和要请求的相对路径合在一起，并将该路径添加到请求头内，来向服务器请求该路径的资源

~~~html
  <img src="../../a.jpg">

    <!-- 假设当前资源的URL为 http://localhost:8080/test/aa.html  -->
    <!-- 那么该资源当前的目录为 http://localhost:8080/test -->
    <!-- 由于其相对路径为 ../../a.jpg,其中每个 ../ 都会使当前目录回退到上一目录，直到回退到端口号无法回退，此时即使还有 ../ 也不再回退，而是直接无视掉该符号 -->
    <!-- 第一个 ../ 会使目录变为: http://localhost:8080 -->
    <!-- 第二个 ../ ，由于已经回退到了8080端口，不再回退，便直接无视掉该符号 -->
    <!-- 因此最后浏览器向服务器请求的资源路径为 http://localhost:8080/a.jpg -->

~~~

+ 但相对路径只根据磁盘进行判断是不可靠的，因为**可能会受到后端请求转发的影响**

~~~html

  <form action="Servlet1">...</form>

  <!-- 假设当前资源的URL为 http://localhost:8080/test/aa.html  -->
  <!-- form表单向Servlet1请求，在Servlet1进行了请求转发，转发到了WEB-INF目录下的bb.html下，因此bb.html会在响应体内被返回给浏览器 -->
  <!-- 而bb.html下有一张图片 <img src="../../a.jpg"> ，以bb.html为中心，该图片的路径应该在WEB-INF的上一级目录下 -->
  <!-- 但请求转发时，浏览器的URL是 http://localhost:8080/test/Servlet1，因为请求转发时是后端的事，前端URL不会变化 -->
  <!-- 因此此时浏览器受到了bb.html文件，但其地址栏不会发生变化，因此它向客户端请求的图片路径为 http://localhost:8080/a.jpg，这显然不对 -->

~~~

#### ②前端绝对路径

+ 浏览器可以通过读取绝对路径来避免相对路径的问题，因为绝对路径不会受到当前资源所在位置的影响，但绝对路径包括了项目的上下文路径，它可能会发生变化
  + 绝对路径要在前面加上`/`
  + 可以通过`head`标签内的`base`标签的`src`属性，来定义所有路径的**公共前缀**，该前缀会在浏览器请求资源时**自动插入到其它标签定义的相对路径之前，但对绝对路径无效**.
  + 虽然这种方式可以避免每次项目重命名时大量修改路径，但每次项目更名时依然要更改`base`中的属性

~~~html

<head>
  <base src="/test/">  
</head>
<body>
  <img src="static/a.img"  />
</body>

  <!-- 
    假设当前资源的URL为 http://localhost:8080/test/aa.html
    此时这个img读取的文件的相对路径实际上是: /test/static/a.img
    因此此时请求的路径为 http://localhost:8080/test/static/a.img
  -->

~~~

---

## 六、Spring问题

|报错信息|报错原因|解决方法|备注|
|:---:|:---:|:---:|:---:|
|`No qualifying bean of type 'com.spring.sample.User' available: expected single matching bean but found 2: xxx,yyy`|xml文件内配置了**两个id同时对应一个类**，且**在获得类对象时是仅通过传入类的Class对象获取的**|使用其它方法获取，或删除多余的标签|无|
|`Error creating bean with name 'xxx' defined in class path resource [xxx.xml]: Unsatisfied dependency expressed through constructor parameter n: Ambiguous argument values for parameter of type [char] - did you specify the correct bean references as arguments?`|未正确配置xml文件中对应类的依赖注入，可能是注入的值与类内的属性对应类型不匹配造成的。`constructor parameter n`提示了是构造器接收的参数列表中下标为n的地方出现了错误|修改配置文件|无|
|`Error creating bean with name 'diSample2' defined in class path resource [xxx.xml]: Unsatisfied dependency expressed through constructor parameter n: Could not convert argument value of type [java类] to required type [char]: Failed to convert value of type 'java类' to required type 'java类'; String [n] with length m cannot be converted to java类 type: neither Unicode nor single character`|依赖注入的值与对应类属性的类型不一致|修改配置文件或修改属性类型|无|
|`Configuration problem: Unexpected failure during bean definition parsing`|xml配置出错，这种情况下idea一般会直接在xml文件内报错|修改配置|无|