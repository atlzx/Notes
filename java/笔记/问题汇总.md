# 问题汇总

## 一、IDEA问题

### （一）idea配置tomcat

1.  可以在`设置(settings)->编辑(editor)->文件编码(File Encodings)`分别为`全局编码(Global Encoding)`、`项目编码(Project Encoding)`、`属性文件的默认编码(Default > Encoding for Properties Files)`设置 全局、项目和`properties`文件的编码类型
2.  在`设置(settings) -> 构建、执行、部署(Build,Execution,Deployment) -> 应用程序服务器(Application Servers) `下可以添加服务器(`tomcat`等)
3.  在模块的`打开模块设置(Project Structure) -> 项目设置(Modules) -> 选择模块 -> 依赖(Dependencies)`可以添加模块所依赖的库(`tomcat`库等)，这些库不能被`Java`库默认提供，因此需要导入
4.  点击项目再按`Shift+Shift`，搜索`框架(frame)`，可以找到`添加框架支持(Add Framework Support)`来添加框架(`Web Application`)支持，该设置需要先添加
5.  在运行按钮边`编辑配置(Edit Configurations) -> 点击加号 -> 选择tomcat 本地(Local) `可以配置`tomcat`的运行配置，如`应用程序服务器(Application Server)`可以选择`tomcat`的版本，`打开浏览器(Open Browser)`可以选择运行时**默认打开的浏览器**、`部署(deployment)`可以添加**运行时具体运行哪个项目**,(`工件(Artifacts)`),`应用程序上下文(Application Context)`设置打开该项目使用的**上下文路径**

---

### （二）快捷键问题

+ 如何关闭连按两次shift出现的全局搜索框?
  + 在设置内找到高级设置(Advanced Settings)，然后找到`disable double modifier key shortcuts`，开启它来禁用
  + 在按键映射中找到`search everywhere`来配置想配置的全局搜索框快捷键

---

### （三）编码问题

+ 在idea设置->Editor->General->Console可以找到**终端输出的默认字符集编码**，默认为系统编码，修改为UTF-8
+ 在idea设置->Editor->File Encodings可以找到**idea的文件编码**，有的默认是GBK和ISO8859-1，修改为UTF-8
+ 在中文环境下，貌似Java的输出流的默认输出编码格式是GBK，但是我们想把它转成UTF-8，但我们又不能在程序内指定，因为**字符集编码格式已经在JVM启动时就被缓存下来**，因此我们需要指定JVM启动时的参数配置:
  + 创建系统环境变量：变量名: `JAVA_TOOL_OPTIONS`， 变量值：`-Dfile.encoding=UTF-8`,这样就可以让idea在控制台的输出编码为UTF-8时输出不再乱码



## 二、tomcat问题

### （一）项目乱码

> 1. `tomcat`打印的日志乱码时，在其**根目录的`conf`文件夹里的`logging.properties`中**修改编码为`GBK`，原因是编码时`tomcat`默认打印日志的编码为`UTF-8`，但操作系统对日志进行解码输出时默认使用操作系统本地的解码,中国地区一般为`GBK`编码，因此**需要让`tomcat`去适应操作系统的解码方式**，所以要将其编码方式设置为`GBK`
> 2. 打开项目的`html`文件乱码时，可能为`html`编码方式与`<meta charset="xxx">`中设置的解码方式不一致，**由于`UTF-8`编码是`html5`文档的唯一有效编码，因此不建议修改`charset`属性**，可以通过修改该文档的编码格式来使其与`charset`属性值保持一致。如果无法修改再考虑修改`charset`属性
> 3. 使用`System.out.println()`方法输出乱码时，可能为两个原因:**1.`idea`在将`java`文件编译为`class`文件时解码和编码不一致2.`JVM`加载`class`类时解码与编码方式不一致**。第一种原因一般不会出现，**因为`idea`比较智能，他会自动识别`java`文件的编码格式并进行编译**。第二种原因则需要**修改`tomcat`运行配置的`虚拟机选项(VM options)`，添加`-Dfile.encoding=UTF-8`**，其中字符集按需要修改
> 4. `get`请求乱码:**在`tomcat根目录 -> conf -> logging.properties`中为`Connector`标签添加属性`URIEncoding`属性(默认编码为`UTF-8`)中并为其设置合适的属性值**，产生乱码的原因是`get`请求通过`URI`进行传递，其使用的编码(即`meta`标签的`charset`属性值)与`tomcat`默认接收信息时的解码方式不一致
> 5. `post`请求乱码:`post`请求不通过`url`进行参数的数据的传递，因此无法通过设置`URIEncoding`属性来解决乱码问题，可以设置`request.setCharacterEncoding("UTF-8")`来设置`tomcat`接收请求体时使用什么方式进行解码
> 6. 响应体乱码问题:
>    1. 可以设置`response.setCharacterEncoding("UTF-8")` 来设置`tomcat`对响应体以什么方式进行编码(**不推荐，因为不同的客户端使用的编码格式可能不同**)
>    2. 可以设置`response.setContentType("text/html;charset=UTF-8")`来**通过响应头的`Content-Type`属性告知客户端响应体的编码格式**

---

### （二）tomcat配置

1. `conf`目录下
  + `server.xml`中的`Connector`标签内可以设置`tomcat`的端口号(`port`)、使用的`HTTP`协议(`protocol`)、解码方式(`URIEncoding`,默认为`UTF-8`)
  + `tomcat-user.xml`用于存储`tomcat`用户信息，如`tomcat`用户的用户名和密码，以及用户的角色信息，可以根据其注释添加
  + `web.xml`用于部署描述符文件，它用来**通过服务器告知浏览器其请求的文档类型**，`tomcat`的`web.xml`文件是**所有项目的共享配置文件，它作用于所有部署于`tomcat`的项目**，里面默认包含了:
    1. 文件类型所对应的`Content-Type`属性值
    2. `tomcat`启动时默认构建的`Servlet`类
    3. 打开项目时默认寻找并打开的文件名(一般为`index.jsp、index.html和index.htm`)
    4. `session`的时效(`<session-config> -> <session-timeout>`)
  + `Catalina`中的`localhost`文件夹内可以新建`xxx.xml`文件以不向`tomcat`的`webapp`目录添加项目，而告知`tomcat`应该去哪里寻找该项目，在`xml`文件中写入`<Context path="xxxx" docBase="xxxx" />`以进行配置，`path`是项目启动时的上下文路径，`docBase`是项目在磁盘中的路径
2. `lib`文件夹用于存放`tomcat`运行时所需的**项目`jar`包**，它可以作用于`webapp`下**所有**的项目
3. `logs`文件夹用于存放`tomcat`运行时的**日志**
  + `logging.properties`用来配置打印时遵循的规则，可以在这里改变编码以应对`tomcat`日志输出乱码
4. `temp`文件夹用于存放`tomcat`的**临时文件**
5. `webapp`文件夹用于存放`tomcat`的**项目文件**，其中的**每一个文件夹都是一个项目**，可以直接通过`http://localhost:8080/项目路径`在浏览器上呈现项目中的文件
6. `work`文件夹主要用于存放与`jsp`相关的文件，其运行时生成的文件都放在该文件夹下
7. `LICENSE`:许可证
8. `NOTICE`:说明文件

---

### （三）报错

|报错信息|报错原因|解决方式|备注|
|:---:|:---:|:---:|:---:|
|`java.lang.IllegalStateException: 启动子级时出错 ... ... 名为 [xxx]和 [xxx] 的servlet不能映射为一个url模式(url-pattern) [/ServletA]`|注解与`web.xml`配置同时设置发生冲突|删去其中一个即可解决|无|
|`java.lang.IllegalStateException: 提交响应后无法调用sendRedirect（）`|调用`session.sendRedirect（）`方法后，**程序不会终止而是会继续执行**，当多次执行到该方法时，就会出现异常|不要在重定向后面写东西|无|
|`Operation not allowed after ResultSet closed`|使用同一个`Statement`进行多次`excuteQuery`或`excuteUpdate`时，执行下一次`exceute`时会将上一次`Statement`对象方法所返回的`ResultSet`方法关闭，此时若再次调用该`ResultSet`对象，便会报错|使用不同的`Statement`进行执行|无|
|IDEA无法识别tomcat的jar包|项目未导入tomcat作为其依赖|`打开模块设置->对应模块->依赖->点击+号->选择添加库->将tomcat导入`|无|

~~~java
  // Operation not allowed after ResultSet closed问题示例
  Stament sta=con.createStatement();
  ResultSet rs=sta.executeQuery("select * from xxx");
  sta.executeUpdate("delete * from xxx where xxxx");
  rs.getString("data");  //报错，因为上次的excuteQuery方法产生的ResultSet对象已经被关闭了，原因是sta在之后执行了excuteUpdate方法
  // 应保证在excuteUpdate方法执行前完成需要rs执行的代码，或者创建多个Statement对象以排除互斥
~~~


---

### （四）路径问题

+ 后端的相对路径与前端实际上是一样的
+ 后端的绝对路径也包括项目的上下文路径，但后端可以通过`getServletContext().getContextPath()`来获取当前项目的上下文路径
+ 如果想彻底结局上下文路径问题，需要在`idea`的`tomcat`运行配置内更改其上下文路径为`/`，这样就不需要考虑上下文路径了，因为上下文路径没了

---

### 注意事项

+ 修改`jsp`文件的父文件名时，需要在&nbsp;`点击模块目录->右键->模块设置->facet`中找到`Web资源目录`，修改其路径，使其路径与修改文件名后的路径相同，否则在原`jsp`文件右键不会弹出`运行xxx.jsp`和`调试xxx.jsp`，而且此时启动项目会报错:`404 Not Found`
+ 如果`idea`在更改`css`样式但网页依旧不变，可能是因为浏览器的自动缓存机制。使用`Ctrl+F5`来使浏览器强制刷新网页，或在开发者工具中关闭缓存

---

## 三、Git问题

### （一）乱码问题

+ 由于`Git`默认的`UTF-8`编码与`cmd`跟随系统的`GBK`编码冲突，会导致乱码
+ 此时需要进行一些设置:

~~~bash
  git config --global core.quotepath false
~~~

+ 然后在`Git bash`右击，打开设置，在`Text`中选择`Local`为zh_CN,同时设置`Character set`为UTF-8

---

### （二）报错

~~~bash
# 如果出现SSH相关错误，可以尝试
git config --global http.sslVerify "false"

# 如果连接不上，可以执行下面的一些代码

git config --global --edit  # 查看和修改git的配置项，用于查看设置是否生效
# 为git配置代理
git config --global http.proxy http://127.0.0.1:7890
git config --global https.proxy http://127.0.0.1:7890

~~~

---

## 四、Maven问题

### （一）报错

|报错信息|报错原因|解决方法|备注|
|:---:|:---:|:---:|:---:|
|`Cannot access alimaven (网址) in offline mode`|1.镜像仓库可能要更新了<br>2.idea或Maven的配置不正确<br>3.idea的Maven设置里勾选了`work offline`选项|1.更新镜像<br>2.重新配置<br>3.取消勾选|无|
|`编码 GBK 的不可映射字符`|Maven默认使用操作系统字符集，即GBK进行编译|在pom.xml文件内添加`<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>`以告知Maven使用UTF-8编译项目|无|
|依赖下载失败|1.网络不好<br>2.依赖项的版本错误或依赖项未正确定义<br>3.本地Maven仓库被污染或损坏|1.挂梯子或使用代理<br>2.纠正依赖项<br>3.清除本地 Maven 仓库缓存（lastUpdated 文件），因为只要Maven检测到该缓存，就不会去中央仓库下载|无|
|`Duplicated tag: 'xxxxxx'`|pom.xml内存在重复的标签|删去重复的标签|无|

---

### （二）配置问题

+ IDEA每新建一个项目，其Maven就会默认成原来的配置。因此，每新建一个项目，都需要配置对应的IDEA的Maven配置

---

## 五、前端问题

### （一）路径问题

#### ①前端相对路径

+ 浏览器在读取相对路径时，会把当前资源所在路径的目录和要请求的相对路径合在一起，并将该路径添加到请求头内，来向服务器请求该路径的资源

~~~html
  <img src="../../a.jpg">

    <!-- 假设当前资源的URL为 http://localhost:8080/test/aa.html  -->
    <!-- 那么该资源当前的目录为 http://localhost:8080/test -->
    <!-- 由于其相对路径为 ../../a.jpg,其中每个 ../ 都会使当前目录回退到上一目录，直到回退到端口号无法回退，此时即使还有 ../ 也不再回退，而是直接无视掉该符号 -->
    <!-- 第一个 ../ 会使目录变为: http://localhost:8080 -->
    <!-- 第二个 ../ ，由于已经回退到了8080端口，不再回退，便直接无视掉该符号 -->
    <!-- 因此最后浏览器向服务器请求的资源路径为 http://localhost:8080/a.jpg -->

~~~

+ 但相对路径只根据磁盘进行判断是不可靠的，因为**可能会受到后端请求转发的影响**

~~~html

  <form action="Servlet1">...</form>

  <!-- 假设当前资源的URL为 http://localhost:8080/test/aa.html  -->
  <!-- form表单向Servlet1请求，在Servlet1进行了请求转发，转发到了WEB-INF目录下的bb.html下，因此bb.html会在响应体内被返回给浏览器 -->
  <!-- 而bb.html下有一张图片 <img src="../../a.jpg"> ，以bb.html为中心，该图片的路径应该在WEB-INF的上一级目录下 -->
  <!-- 但请求转发时，浏览器的URL是 http://localhost:8080/test/Servlet1，因为请求转发时是后端的事，前端URL不会变化 -->
  <!-- 因此此时浏览器收到了bb.html文件，但其地址栏不会发生变化，因此它向客户端请求的图片路径为 http://localhost:8080/a.jpg，这显然不对 -->

~~~

#### ②前端绝对路径

+ 浏览器可以通过读取绝对路径来避免相对路径的问题，因为绝对路径不会受到当前资源所在位置的影响，但绝对路径包括了项目的上下文路径，它可能会发生变化
  + 绝对路径要在前面加上`/`
  + 可以通过`head`标签内的`base`标签的`src`属性，来定义所有路径的**公共前缀**，该前缀会在浏览器请求资源时**自动插入到其它标签定义的相对路径之前，但对绝对路径无效**.
  + 虽然这种方式可以避免每次项目重命名时大量修改路径，但每次项目更名时依然要更改`base`中的属性

~~~html

<head>
  <base src="/test/">  
</head>
<body>
  <img src="static/a.img"  />
</body>

  <!-- 
    假设当前资源的URL为 http://localhost:8080/test/aa.html
    此时这个img读取的文件的相对路径实际上是: /test/static/a.img
    因此此时请求的路径为 http://localhost:8080/test/static/a.img
  -->

~~~

---

## 六、Spring问题

### （一）运行报错

|报错信息|报错原因|解决方法|备注|
|:---:|:---:|:---:|:---:|
|No qualifying bean of type 'com.spring.sample.User' available: expected single matching bean but found 2: xxx,yyy|xml文件内配置了**两个id同时对应一个类**，且**在获得类对象时是仅通过传入类的Class对象获取的**|使用其它方法获取，或删除多余的标签|无|
|Error creating bean with name 'xxx' defined in class path resource [xxx.xml]: Unsatisfied dependency expressed through constructor parameter n: Ambiguous argument values for parameter of type [char] - did you specify the correct bean references as arguments?|未正确配置xml文件中对应类的依赖注入，可能是注入的值与类内的属性对应类型不匹配造成的。`constructor parameter n`提示了是构造器接收的参数列表中下标为n的地方出现了错误|修改配置文件|无|
|Error creating bean with name 'diSample2' defined in class path resource [xxx.xml]: Unsatisfied dependency expressed through constructor parameter n: Could not convert argument value of type [java类] to required type [char]: Failed to convert value of type 'java类' to required type 'java类'; String [n] with length m cannot be converted to java类 type: neither Unicode nor single character|依赖注入的值与对应类属性的类型不一致|修改配置文件或修改属性类型|无|
|Configuration problem: Unexpected failure during bean definition parsing|xml配置出错，这种情况下idea一般会直接在xml文件内报错|修改配置|无|
|No qualifying bean of type 'xxx' available|1.bean配置出错<br>2.配置的扫描路径不正确<br>3.创建的context对象不正确|1.修改bean配置<br>2.更改扫描路径<br>3.修改创建语句|无|
|Property or field 'name' cannot be set on object of type 'xxx' - maybe not public or not writable?|未设置属性的setter方法，或属性不可写|设置setter方法或修改写权限|无|
|Bean named 'XXX' is expected to be of type 'TTT' but was actually of type 'TTT'|@AutoWired注解作用的对象所显式声明的类型是实现了接口类型的具体实现类，导致Spring无法注入|将具体实现类类型改为接口类型|无|


---

### （二）编译报错

|报错信息|报错原因|解决方法|备注|
|:---:|:---:|:---:|:---:|
|Autowired members must be defined in valid Spring bean|使用Autowired注解修饰的属性所属的类不是Bean,大概率是因为**没有写Component之类的注解**|加上Component之类的注解|无|
|Could not autowire. No beans of 'xxx' type found.|没有Bean的名称叫'xxx'，无法自动装载|1.在配置类中使用Bean注解提供一个Bean<br>2.在xml文件内提供bean<br>3.为对应的类添加Component之类的注解，给它的bean起别名|无|

---

## 七、mybatis问题

|报错信息|报错原因|解决方法|备注|
|:---:|:---:|:---:|:---:|
|Could not find resource 'xxx'|找不到对应路径下的文件，可能是路径写错了|确认路径|无|
|Could not set property 'xxx' of 'yyy' with value 'zzz' Cause: java.lang.IllegalArgumentException: argument type mismatch|插入值与属性类型不匹配|修改属性或插入值类型|无|
|Type interface xxx is not known to the MapperRegistry.|可能是配置路径不对|检查getResourceAsStream方法、mybatis-config.xml内的mapper路径、typeAliases标签下的路径是否正确|无|
|Invalid bound statement (not found)|未成功找到Mapper接口对应的xml文件，可能是由于SpringBoot项目未配置mybatis.mapper-locations配置或配置路径错误导致的|把配置写好|无|

---

## 八、SpringMVC问题

|报错信息|报错原因|解决方法|备注|
|:---:|:---:|:---:|:---:|
|Invalid mapping on handler class|一些注解上（如RequestMapping）配置的路径匹配非法|修改路径匹配的逻辑|无|
|Name for argument of type xxx not specified, and parameter xxx information not available via reflection. Ensure that the compiler uses the '-parameters' flag.|可能没有写@RequestParam之类的注解|写上|无|
|There is already 'xxx' bean method yyy#zzz() mapped|多个方法对应着相同的匹配路径，导致路径映射出现冲突|按照报错信息提示找到对应方法，然后改|无|
|Request method 'xxx' is not supported|1.tomcat部署的artifact不正确<br>2.请求方式不正确<br>3.没有重新部署修改后的代码到tomcat|1.修改tomcat配置<br>2.修改请求方式<br>3.重新部署|无|
|Content-Type 'application/json;charset=UTF-8' is not supported.|java默认不能识别json类型，需要导入第三方依赖|确认jackson等json相关依赖是否正常导入，或SpringMVC的配置类是否实现了WebMvcConfigurer接口|无|
|Acceptable representations: [application/json, application/*+json].|实体类可能没有实现对应的getter和setter等方法|确认一下|无|
|Required request body is missing|1.未传递参数<br>2.参数传递不正确<br>3.参数传递方式有误（如想传的是json，但是实际上传的param）|仔细检查|无|
|SqlSession [xxx] was not registered for synchronization because synchronization is not active|没有在Service层加上@Transactional注解导致事务管理无法同步|加上|无|
|Error creating bean with name 'sqlSessionFactoryBean' defined in com.springmvc.example.config.MapperConfigNew: Failed to parse mapping resource: 'class path resource xxx'|1.配置文件配置方式不正确<br>2.配置文件所在路径不正确|1.检查文件配置，尤其需要检查**起别名的配置需要配置的是pojo包下的类**<br>2.确保批量映射时对应xml文件所在的包与mapper对应接口所在包的classpath路径是一致的|无|
|Error resolving class. Cause: org.apache.ibatis.type.TypeException: Could not resolve type alias 'xxx'.  Cause: java.lang.ClassNotFoundException: Cannot find class: xxx|^|^|^|

---

## 九、SpringBoot问题

### （一）报错问题

|报错信息|报错原因|解决方法|备注|
|:---:|:---:|:---:|:---:|
|Failed to configure a DataSource: 'url' attribute is not specified and no embedded datasource could be configured.<br>Reason: Failed to determine a suitable driver class|未配置数据库url，导致**SpringBoot无法根据url推断数据库类型而选择对应的数据库驱动**|在application.properties文件内写入`spring.datasource.url=jdbc:mysql://127.0.0.1:3306/atguigudb`的语句|无|
|406状态码|1.没有导入相应的格式转换依赖，项目无法进行对应格式转换<br>2.请求的参数不正确，尤其是路径参数，它的值与请求头参数的值是不一样的，且必须得写指定的参数名|1.导入对应依赖<br>2.把路径参数写对|无|
|No message found under code 'xxx' for locale 'aaa_bbb'.|1.没有创建messages.properties文件或文件不在指定目录下<br>2.寻找的key的值在文件内找不到<br>3.创建的国际化文件与配置文件中的设置项不匹配|1.改<br>2.改<br>3.改|无|
|Resolved [org.springframework.web.HttpMediaTypeNotAcceptableException: No acceptable representation]|1.后端无法转换前端请求的格式<br>2.被转换格式的类（这里特指我们自定义的类）未提供setter方法|1.添加对应的格式转换依赖/前端修改请求格式<br>2.加一个@Data注解|无|

---

### （二）路径问题

+ 目前项目有三个路径:
  + 项目的根路径一般是:`http://localhost:8080/`
  + 上下文路径，默认`/`，但我们可以通过`server.servlet.context-path`配置手动指定
  + 请求路径，该路径是在上下文路径之后的，**我们指定静态资源匹配的路径原则是指定的这里**
    + 如通过spring.mvc.static-path-pattern配置
    + 或者通过spring.mvc.webjars-path-pattern配置
+ 现在假设我们的上下文路径不是默认的`/`了，而是`/demo`。同时前端的匹配请求路径原则是`/**`，而且在类路径下的static/img目录下有一个1.jpg文件:
  + 当前端使用img标签请求`http://localhost:8080/1.jpg`目录时，也就是img标签的src是`1.jpg`时，**SpringBoot匹配前端路径时，匹配的是上下文路径与匹配原则结合起来的路径**，也就是说，只有当我们在无视根路径时，前端请求的全路径为`/demo/1.jpg`时，才会触发SpringBoot的静态资源寻找的响应，不然SpringBoot是不认识这个请求路径的
  + 因此我们需要把src的路径改为`上下文路径+我们想请求的资源路径`，也就是`src="/demo/1.jpg"`，这样SpringBoot先匹配到了上下文路径，将上下文路径切下得到后面的路径`/1.jpg`，满足我们所指定的前端的匹配请求路径原则是`/**`。因此SpringBoot会从默认的四个静态资源目录下去寻找该资源
  + 同理，在我们请求非静态资源时，也就是**我们向服务器发送业务请求时，也需要带上上下文路径**
+ 省流:**我们指定前端的匹配请求路径原则时不需要带上下文路径，但是我们请求时，必须带上下文路径作为前缀**

---

## 依赖汇总

### （一）Spring相关依赖

~~~xml

        <properties>
            <maven.compiler.source>17</maven.compiler.source>
            <maven.compiler.target>17</maven.compiler.target>
            <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>

            <spring.version>6.1.5</spring.version>
            <junit.version>5.10.2</junit.version>
            <log4j.version>2.20.0</log4j.version>
            <annotation.version>2.1.1</annotation.version>
            <mysql-connection.version>8.0.33</mysql-connection.version>
            <druid.version>1.2.22</druid.version>
        </properties>

        <dependencies>
            <!-- Spring核心框架 -->
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-context</artifactId>
                <version>${spring.version}</version>
            </dependency>
            <!--spring aop依赖-->
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-aop</artifactId>
                <version>${spring.version}</version>
            </dependency>
            <!--spring aspects依赖-->
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-aspects</artifactId>
                <version>${spring.version}</version>
            </dependency>
            <!-- spring-jdbc依赖 -->
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-jdbc</artifactId>
                <version>6.1.5</version>
            </dependency>
            <!-- JDK注解拓展，有一些依赖注入的注解 -->
            <dependency>
                <groupId>jakarta.annotation</groupId>
                <artifactId>jakarta.annotation-api</artifactId>
                <version>${annotation.version}</version>
            </dependency>
            <!-- spring junit兼容依赖 -->
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-test</artifactId>
                <version>${spring.version}</version>
            </dependency>
            <!-- junit依赖，用来测试 -->
            <dependency>
                <groupId>org.junit.jupiter</groupId>
                <artifactId>junit-jupiter-api</artifactId>
                <version>${junit.version}</version>
            </dependency>
            <!-- MySQL驱动 -->
            <dependency>
                <groupId>mysql</groupId>
                <artifactId>mysql-connector-java</artifactId>
                <version>${mysql-connection.version}</version>
            </dependency>
            <!-- Druid连接池 -->
            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>druid</artifactId>
                <version>${druid.version}</version>
            </dependency>
            <!-- log4j依赖，用来输出日志 -->
            <dependency>
                <groupId>org.apache.logging.log4j</groupId>
                <artifactId>log4j-core</artifactId>
                <version>${log4j.version}</version>
            </dependency>
            <!-- log4j2，用来输出日志 -->
            <dependency>
                <groupId>org.apache.logging.log4j</groupId>
                <artifactId>log4j-slf4j2-impl</artifactId>
                <version>${log4j.version}</version>
            </dependency>
        </dependencies>

~~~

---

### （二）Mybatis相关依赖

~~~xml

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>

        <pageHelper.version>6.1.0</pageHelper.version>
        <mybatis.version>3.5.11</mybatis.version>
        <mybatis-spring.version>3.0.3</mybatis-spring.version>
    </properties>

    <dependencies>
        <!-- Mybatis的分页插件依赖 -->
        <dependency>
            <groupId>com.github.pagehelper</groupId>
            <artifactId>pagehelper</artifactId>
            <version>${pageHelper.version}</version>
        </dependency>
        <!-- Mybatis依赖 -->
        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis</artifactId>
            <version>${mybatis.version}</version>
        </dependency>
        <!-- mybatis适配spring依赖 -->
        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis-spring</artifactId>
        </dependency>
    </dependencies>
~~~

---

### （三）SpringMVC

~~~xml

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        
        <servlet.version>6.0.0</servlet.version>
        <lombok.version>1.18.32</lombok.version>
        <jackson.version>2.17.0</jackson.version>
        <hibernate-validator.version>8.0.1.Final</hibernate-validator.version>
        
    </properties>

    <dependencies>
        <!-- servlet -->
        <dependency>
            <groupId>jakarta.servlet</groupId>
            <artifactId>jakarta.servlet-api</artifactId>
            <version>${servlet.version}</version>
        </dependency>
        <!-- lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>${lombok.version}</version>
        </dependency>
        <!-- jackson依赖 -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>${jackson.version}</version>
        </dependency>
        <!-- hibernate校验依赖 -->
        <dependency>
            <groupId>org.hibernate.validator</groupId>
            <artifactId>hibernate-validator</artifactId>
            <version>${hibernate-validator.version}</version>
        </dependency>
    </dependencies>

~~~

---

### （四）SpringBoot

~~~xml
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.0.5</version>
        <!-- 
          该标签的作用是Maven在查找依赖时先从该标签指定的本地路径下（这个本地路径不是仓库路径，而是父项目的pom.xml路径）查找，找不到再找本地仓库，找不到再找全局仓库
          但是不写IDEA（比较老的版本可能不报）可能会报错
          将该标签设置为空体可以使Maven直接从本地仓库中寻找依赖项，就直接绕过了本地路径
         -->
        <relativePath/>
    </parent>

    <dependencies>
        <!-- Spring关于Web开发的场景启动器 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <!-- SpringBoot项目自带的测试相关的场景启动器 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <!-- 导入Thymeleaf场景启动器 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>
        <!-- 导入properties与Properties自定义配置类的映射提示依赖 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-configuration-processor</artifactId>
            <optional>true</optional>
        </dependency>
        <!-- 导入log4j2的场景启动器 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-log4j2</artifactId>
        </dependency>
        <!-- 导入jackson的xml转换依赖，SpringBoot默认支持xml转换，但是没有提供依赖 -->
        <dependency>
            <groupId>com.fasterxml.jackson.dataformat</groupId>
            <artifactId>jackson-dataformat-xml</artifactId>
        </dependency>
        <!-- jackson转yaml格式的依赖 -->
        <dependency>
            <groupId>com.fasterxml.jackson.dataformat</groupId>
            <artifactId>jackson-dataformat-yaml</artifactId>
        </dependency>
        <!-- Spring提供的热部署依赖，添加后只需要ctrl+F9来重新构建项目，就能执行热部署 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
      </dependency>
    </dependencies>
~~~