
## 项目亮点

+ 使用AOP+自定义注解实现登录校验功能
+ 使用自定义Decoder校验feign远程调用返回值的数据是否为空以及状态码是否合法，减少代码冗余
+ 使用阿里云OSS和OCR进行数据的存储和身份证、驾驶证等信息的识别，使用腾讯云的IAI进行人脸识别认证
+ 使用Drools规则引擎进行代驾路费的计算，免去硬编码写if-else语句的缺点
+ 使用redis的GEO数据类型查找方圆指定公里数的司机数



## 碰到的问题

+ OpenFeign请求404问题:路径参数为空导致无法匹配，而路径参数为空的原因是没有添加自定义的登录校验注解。或者@XxxMapping相关注解没有使用value属性
+ Nacos崩溃问题:分配给nacos的内存不是太多，导致nacos内存占用不够崩掉
+ `Error converting request body`:Feign在转发请求时，如果请求带文件对象，需要制定XxxMapper注解的consumes属性为`MediaType.MULTIPART_FORM_DATA_VALUE`

# 项目模块划分

+ 总共有6个大模块
  + common:放各个模块通用的枚举类、常量类、方法工具类和全局AOP类等
  + model:对应的数据库关系实体、前后端数据交互的实体类
  + service-gateway:网关
  + service:微服务模块的被调用模块
  + service-client:微服务的Feign接口模块，存放各个feign接口，其模块内部结构与service保持一致
  + web:网关转发请求后先到达的模块，也是调用接口的模块
+ service模块:
  + service-coupon:
  + service-customer:与顾客相关的模块，包括登录和用户信息获取等
  + service-dispatch:
  + service-driver:与司机相关的模块，包括登录与司机信息获取等
  + service-map:与地图相关的模块，包括驾驶路线获取、司机位置相关的方法等
  + service-mq:
  + service-order:与订单相关的模块，包括用户订单保存等
  + service-payment:
  + service-rules:与规则相关的模块，包括按照计费规则进行费用计算等
  + service-system:
+ web模块:
  + web-customer:乘客端的web模块
  + web-driver:司机端的web模块
  + web-mgr:这好像是管理员的



## 登录模块

+ 乘客登录
  + 使用微信小程序提供的openid(用于唯一标识每个微信用户)进行登陆验证
    + 前端向后端发送请求，携带一个code值
    + 请求经网关转发到web端，web端再将请求转发到内部的service端进行登录处理
    + service端处理完毕后，若处理完成，则返回customerId
    + web端校验该customerId，若不为空，则生成token，并将token和customerId放入redis并设置过期时间
    + 最后把token返回给前端
  + 自定义FeignCustomDataDecoder来处理feign进行远程调用后得到的结果，进行判空与返回状态码合法性校验
    + 具体为:
      + 先写一个自定义类，实现Decoder接口并实现方法，在方法中编写判断逻辑
      ~~~java
        @Slf4j
        // 让自定义类实现Decoder(feign.codec.Decoder)接口
        public class FeignCustomDataDecoder implements Decoder {
            // 里面写一个属性，该属性为SpringDecoder类型的解析器
            private final SpringDecoder decoder;
            public FeignCustomDataDecoder(SpringDecoder decoder) {
                // 初始化的时候赋值
                this.decoder = decoder;
            }

            @Override
            // 重写该方法，进行逻辑判断
            public Object decode(Response response, Type type) throws IOException, DecodeException, FeignException {
                log.info("{}","自定义feign-decoder开始执行");
                // 解析得到返回值结果
                Object obj=this.decoder.decode(response,type);
                // 先检查obj是否为空
                if(null==obj){
                    throw new DecodeException(ResultCodeEnum.FEIGN_FAIL.getCode(),ResultCodeEnum.FEIGN_FAIL.getMessage(),response.request());
                }
                // 判断obj是否为Result类型
                if(obj instanceof Result<?> res){
                    // 若状态码不是成功状态码，抛出异常
                    if (res.getCode().intValue()!=ResultCodeEnum.SUCCESS.getCode().intValue()) {
                        throw new DecodeException(res.getCode(),res.getMessage(),response.request());
                    }
                    // 若返回数据为空，抛出异常
                    if(null==res.getData()){
                        throw new DecodeException(ResultCodeEnum.FEIGN_FAIL.getCode(),ResultCodeEnum.FEIGN_FAIL.getMessage(),response.request());
                    }
                    log.info("{}","自定义feign-decoder执行完毕");
                    return res;
                }
                log.info("{}","自定义feign-decoder执行完毕");
                return obj;
            }
        }
      ~~~
      + 接下来在配置类中返回:
      ~~~java
        @Configuration
        public class FeignConfig {
            // 自定义feign解析器
            @Bean
            public Decoder decoder(ObjectFactory<HttpMessageConverters> msgConverters, ObjectProvider<HttpMessageConverterCustomizer> customizers) {
                // 返回
                return new OptionalDecoder((new ResponseEntityDecoder(new FeignCustomDataDecoder(new SpringDecoder(msgConverters, customizers)))));
            }
        }
      ~~~
+ 司机登录
  + 也是用code得到openId,如果初次登录，需要初始化司机信息、司机的接单设置、司机账户信息，然后返回司机id，最后生成token,token和id存入redis，并向前端返回token
  + 登陆后需要认证，上传身份证和驾驶证，并进行人脸识别认证

## 预估订单模块

+ 预估订单模块需要实现:
  + 乘客端选择起始和结束位置，后端进行路线规划与收费预估的计算，使用腾讯地图的API和Drools引擎分别进行路线规划和计费计算
  + 司机端开启接单，流程为: 开启接单，设置其状态 -> 后端根据司机id得到其driverSet对象，依据其状态更新其地理位置数据到redis
  + 用户下单时，流程为 重新计算所需里程和费用 -> 保存订单信息(得到订单id) ->  执行任务调度 -> 返回给前端订单id，该流程也是web端的service层进行远程调用的逻辑
    + 任务调度比较麻烦，其后端具体业务逻辑为:
      + web端通过feign接口进行远程调用
      + dispatch模块的controller接收到以后，通过service层调用XxlJobClient处理转发（通过RestTemplate）到xxl-job的调度中心，得到结果以后插入OrderJob到数据库
      + xxl-job的调度中心根据请求进行调度（已经在代码中插入了对应url的处理方式）
      + 调度任务到具体的OrderJobHandler执行对应的任务（这里先初始化一下OrderJobLog日志对象，再转发，最后执行完毕时会把日志对象插到数据库）
      + 该任务再调用service层的对应方法执行业务（先检查数据库中是否存在该订单，以及该订单状态是否为待接单，之后查找周围指定公里数的可用司机，并根据司机设置的个性化接单设置进行过滤，再通过redis的list数据结构存储向满足条件的司机存储该订单信息）

---

## 司机模块

+ 司机模块的主要业务有:
  + 登录:登陆验证
  + 证件识别:登陆以后需要进行证件识别才能进行接单
  + 开启接单:先判断司机是否进行了今天的人脸识别认证，进行了再更新redis的司机位置，清空司机之前的接单栈
  + 抢单:先判断是否有单，没有再进行抢单，使用分布式锁进行抢单，抢到时把订单状态修改一下
  + 司乘同显:

---
