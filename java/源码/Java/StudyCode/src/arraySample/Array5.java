package arraySample;

public class Array5 {
    public static void main(String[] args) {

        // 数组的二分查找、冒泡排序和快速排序

        // 下面先演示二分查找
        // 定义一个排序好的数组
        int[] arr1 = new int[]{-99,-54,-2,0,2,33,43,256,999};
        int target=-53;  // 指定要查找的值
        boolean isFind=false;  // 定义数组是否找到的变量
        for(int left=0,right=arr1.length-1; left<=right; ){
            int middle=(left+right)/2;
            if(arr1[middle]>target){
                right=middle-1;  // 如果中间索引的值比想寻找的值大，那么缩小范围到middle索引的左侧
            }else if(arr1[middle]<target){
                left=middle+1;  // 如果中间索引的值比想寻找的值大，那么缩小范围到middle的右侧
            }else{
                System.out.println("该值对应的数组下标索引为"+middle);
                isFind=true;  // 将isFind变量设置为true,并跳出循环
                break;
            }
        }
        // 判断是否找到，如果未找到输出数组内不存在该元素
        if(!isFind){
            System.out.println("数组内不存在该元素");
        }


        // 下面演示冒泡排序

        int[] arr2=new int[]{3,6,4,5,11,10,2};

        for (int i = 0; i < arr2.length - 1; i++) {
            // 由于每次冒泡操作都会使待排序序列里最大的值交换到数组最后，因此每进行一次外层循环，最大值就会跑到最后
            // 因此每进行一次外层循环，下一次内层循环执行的次数就可以减少一，以避免后面已经确定是最大值且有序的序列进行比较而浪费时间
            for(int j=0;j<arr2.length-1-i;j++){
                if(arr2[j]>arr2[j+1]){
                    int temp=arr2[j];
                    arr2[j]=arr2[j+1];
                    arr2[j+1]=temp;
                }
            }
        }
        System.out.println("输出冒泡排序好的数组元素:");
        for (int i = 0; i < arr2.length; i++) {
            System.out.print(arr2[i]+" ");
        }
        System.out.println();


        // 下面演示快速排序
        /*
            快速排序是对冒泡排序的一种改进，同时运用了递归调用和二分法的思想，加快了排序效率
            快速排序的思路是首先选中一个用来进行分割的标志值(一般选择当前数组区间内的第一个值)，把比它大的值放在其右边，比它小的值放在其左边
            为了实现这一目的，就需要定义两个变量，一个变量从前向后遍历(从标志值之后的那一个元素开始)，一个变量从后向前遍历，当这两者分别碰到比标志值大的和比标志值小的变量且二者未会合时，交换两个变量的值
            重复上述操作，直到两个变量会合。会合后，让标志值(此时它还是数组区间的第一个)与最后交换的那个从前向后遍历的下标索引的值进行交换
            因为是最后一个交换的，因此处于比标志值大和比标志值小的边界位置，只要使其与标志值交换，那么就实现了“比它大的值在其右边，比它小的值在其左边”的目的
            此时数组由于标志变量的存在已经被分割成了两段，接下来对这两段继续重复上述操作，也就是进行递归调用，直到到达临界条件而退出递归，当递归结束时，数组也就排序成功了
            一般临界条件是区间的开始索引大于等于结束索引，当分段中的元素仅剩下两个时，可以单独进行一次判断即可

            上述操作在实现时可能会出现问题，关键在于上述操作的标志值必须是其后面的值交换完毕后才进行交换的，也就是说，这样做需要确保在标志值进行交换前至少交换一次。
            但在极端情况下，如标志值后面的值全是比它小的，如果此时代码先进行的是从前向后的判断，那么很容易出现问题
            因此，我们可以把这个标志变量也参与到交换的过程中去，而不是等到交换完再进行交换，此时从前向后遍历所碰到的第一个元素就是它本身(之前是直接从它后面的那个元素开始的)
            为了实现这个目的，我们就要改变一下思路:
            最开始时，标志值位于左侧(假定我们找的标志值是数组区间内的第一个值，它就在最左侧)，它认为它的右侧全部都是比它大的，因此我们要从后向前找到比它小的反例，然后与之进行交换
            交换位置的好处是，它可以使标志值右侧的数全部比它大，也能使刚刚找到的反例因为交换位置而跑到相对于标志值左侧的位置，从而相对于交换位置后的标志值，它不再是反例
            交换后，标志值右侧一定就是比它大的值了。因为已经遍历过一次了，此时标志值认为其左侧的值全部比它小，因为我们需要从前向后找到比它大的反例，然后与之交换
            这次交换位置的好处是，它可以使标志值左侧的数全部比它小，也能使刚刚找到的反例因为交换位置而跑到相对于标志值右侧的位置，从而相对于交换位置后的标志值，它不再是反例
            交换后，该标志值左侧可以确定全部比它小，因为已经遍历过一次了，接下来就要继续检查右侧是否全部都比它大
            我们从上一次从后向前遍历的结束位置向前检查，因为在结束位置之后的值已经遍历过一次了，不用再遍历了。找到了反例，那么与之交换
            然后再检查左侧是否全都是比标志值小的值，从上一次从前向后遍历的结束位置向后检查，找到反例，与之交换
            接下来就是重复上面的操作了，可以看出，每次遍历的开始位置都是从上一次的结束位置开始遍历的，第一次开始遍历时可以理解为上一次遍历的结束下标分别为begin和end
            当从前向后的指针与从后向前的指针相遇时，遍历就结束了。
            由此可以看出，一次从后向前的遍历+一次从前向后的遍历就可以构成一次外层循环,循环结束条件是i(表示从前向后的指针)>=j(表示从后向前的指针)
            内层循环(即两次遍历，从后向前的遍历和从前向后的遍历)结束的条件是i<j或碰到了比标志值小或大的元素
        */
        arr2=new int[]{3,6,4,5,11,5,10,2,5};
        sort(arr2,0,arr2.length-1);
        System.out.println("输出快速排序好的数组元素:");
        for(int i=0;i<arr2.length;i++){
            System.out.print(arr2[i]+" ");
        }
    }

    // 快速排序需要使用递归
    public static void sort(int[] arr,int begin,int end){
        // 当开始索引大于等于结束索引时，直接返回
        if(begin>=end){
            return;
        }
        // 当区间内仅剩下两个值时，单独判断
        if(begin+1==end&&arr[begin]>arr[end]){
            int temp=arr[begin];
            arr[begin]=arr[end];
            arr[end]=temp;
            return;
        }
        int index=begin;  // 定义变量，表示当前用来分隔的当前数组元素值的下标索引
        // 开始循环
        for( int i=begin+1,j=end; i<j; ){
            // 首先先从后向前，在开始索引和结束索引不会合的前提下，如果找到了比分段依据值小的值，则二者交换位置并更新index的值并跳出循环
            for( ; i<j; j--){
                if(arr[j]<arr[index]){
                    int temp=arr[index];
                    arr[index]=arr[j];
                    arr[j]=temp;
                    index=j;
                    break;
                }
            }
            // 从后向前找完后，接下来从前向后找，在开始索引和结束索引不会合的前提下，如果找到了比分段依据值大的值，则二者交换位置并更新index的值并跳出循环
            for( ; i<j; i++){
                if(arr[i]>arr[index]){
                    int temp=arr[index];
                    arr[index]=arr[i];
                    arr[i]=temp;
                    index=i;
                    break;
                }
            }
        }
        // 接下来递归调用，对已经分割好的两段继续重复操作，直到只剩下两个值或begin和end冲突
        sort(arr,begin,index-1);
        sort(arr,index+1,end);
    };
}
