# 第一部分：Python基本语法

## 一、变量和数据类型

### （一）变量

+ 不做赘述
+ ``Python``的**变量本身没有类型**，而其记录的数据有类型

---

### （二）数据类型

|类型|描述|说明|
|---|---|---|
|数字类型(`Number`)|包含整型(`int`)|整型表示整数|
|^|浮点型(`float`)|浮点型表示小数|
|^|复数(`complex`)|复数表示复数(如`4+3j`，以j结尾表示复数)|
|^|布尔类型(`bool`)|布尔包括逻辑真(`True`,本质为`1`)和逻辑假(`False`,本质为`0`)，用于判断|
|字符串类型(`str`)|描述文本的一种数据类型|字符串由任意数量的字符组成|
|列表(`list`)|有序的可变序列|``Python``中使用最频繁的数据类型，可以有序记录一堆数据|
|元组(`tuple`)|有序的不可变序列|可有序记录一堆不可变的``Python``数据集合|
|集合(`set`)|无序不重复集合|可无序记录一堆不重复的``Python``数据集合|
|字典(`Dictionary`)|无序`Key-Value`集合|可无序记录一堆`Key-Value`类型的``Python``数据集合|

> 1. **整数**:
>    + `python`中的整数**几乎没有限制大小**，因此变量能够存储的整数值上限取决于计算机内存大小，且**整数永远是精确的**
> 2. **浮点数**:
>    + 浮点数可以用数学上的小数表示，也可以用科学计数法表示，其科学计数法表示为`<a>e<n>`，等价于数学上的`a*10^n`
>       + 例如:`2.53e3`等价于`2.53*10^3`
>    + 由于计算机以二进制存储数据的原因，将二进制转换为十进制可能会出现误差，因此**浮点数不能保证百分之百的精确**
> 3. **布尔(`bool`)类型**:
>    + 布尔类型有两种字面量:`True`和`False`
>    + 由于布尔类型得两个字面量**本质都是数字**，根据实践，它可以转化为所有数字类型和字符串类型的数据（`True`可以转化为`1`、`1.0`、`1+0j`、"`True`"，`False`转化为`0`、`0.0`、`0j`、"`False`"）,同理，任何数字类型的数据（不包括字符串）都可以转化为布尔类型数据，具体为数字只要等于`0`，为`False`，数字不为`0`，为`True`。
>    + `python`中一切空对象的布尔值都为`False`,一切非空对象的布尔值都为`True`

---

<a id="python_carry"></a>

### （三）末位取舍算法

+ `python`的末位取舍算法决定小数的进位:
  + **四舍六入**
  + 当末位为5时，若5**后面的位数至少有一个非0，则进位**；若后面的位数全为0，则**参照前一位数字的奇偶性**进位:
    + 若为**偶数则不进位**
    + 若为**奇数则进位**

---

## 二、标识符

+ 用户编写代码时，对变量、类、方法(函数)等编写的名字，叫做标识符
+ 命名规则
  + 内容限定
    + (**只允许**出现英文、中文、数字、下划线)
    + 数字**不能**写在最前面
    + **不推荐**使用中文

  + 大小写敏感
  + 不能使用`Python`自带的关键字

---

## 三、算数(数学)运算符

+ 本处仅收录与`C`和`Java`语法不同的运算符

|运算符|作用|
|:---:|:---:|
|`/`|数学意义上的除法，会算出来小数 |
|`//`|整除|
|`*`|该运算符可以做许多事:<br>1.乘法<br>2.`a=a*10`当`a`为数据容器时，将`a`中的全部元素复制十份，按先后顺序存入原容器然后赋值给`a`<br>3.`print(*(range(0,11,2)))`解包输出|
|`**`|取某数的x次方|
|`<<`|二进制位左移，相当于某个数乘以`2`的`n`次幂|
|`>>`|二进制位右移，相当于某个数除以`2`的`n`次幂|
|`\`|换行|
|`:=`|`if (age:=20)>18:`<br>等价于<br>`age=20`<br> `if age>18:`|

---

## 四、if else语句

### （一）相关运算符

|关键字|格式|描述|备注|
|:---:|:---:|:---:|:---:|
|`==`|判断语句1 `==` 判断语句2|判断左右侧内容是否相等|无|
|`!=`|判断语句1 `!=` 判断语句2|判断左右侧内容是否不等|^|
|`>=`|判断语句1 `>=` 判断语句2|判断左侧内容是否大于等于右侧内容|^|
|`<=`|判断语句1 `<=` 判断语句2|判断左侧内容是否小于等于右侧内容|^|
|"`>`"(`>`)|判断语句1 `>` 判断语句2|判断左侧内容是否小于等于右侧内容|^|
|`<`|判断语句1 `<` 判断语句2|判断左侧内容是否小于右侧内容|^|
|`is`|变量 `is` 变量|判断两个变量是否引自同一个对象|可以使用`id()`函数判断其真假性，若`id`一致则为真，若不一致则为假|
|`is not`|变量 `is not` 变量|判断两个变量是否引自不同对象|可以使用`id()`函数判断其真假性，若`id`一致则为假，若不一致则为真|
|`in`|变量 `in` 变量|判断该变量是否在指定序列中存在|无|
|`not in`|变量 `not in` 变量|判断该变量是否不存在于指定序列|无|
|`and`|判断语句1 `and` 判断语句2|`&&`的意思|无|
|`or`|判断语句1 `or` 判断语句2|`\|\|`的意思|无|
|`not`|`not` 判断语句|`!`的意思|无|

+ `Python`**支持在if语句中写数学不等式**，例：

~~~python
    money=10
    if(4<=money<=11):
      print("在区间范围内")
    else:
      print("不在范围内")
~~~

---

### （二）基本语句

+ `if else`语句的格式：

+ ~~~python
    if 条件语句:
      执行语句
    elif 条件语句:
      执行语句
    elif 条件语句:
      执行语句
    else:
      执行语句
  ~~~

+ `if(条件语句):`的格式是被允许的，但规范并不推荐这样写
+ **`Python`通过换行与缩进来决定语句之间的层次关系**，想执行的满足`if`条件的执行语句需要与`if`相隔4个空格
+ 其它语法与执行过程与`C`大致相似，不做赘述。

---

### （三）嵌套语句

+ 嵌套格式

+ ~~~python
    if 条件语句1:
      执行语句
      执行语句
      if 条件语句2：
        执行语句
        执行语句
    elif 条件语句3:
      执行语句
    else:
      执行语句
  ~~~

+ 其它语法与执行过程与`C`大致相似，不做赘述。

---

## 五、循环

### （一）while循环

#### ①基本格式

+ ~~~python
    while 条件语句:
      执行语句
  ~~~

+ 例:

+ ~~~python
    #求1到100的和
    i = 1
    sum = 0
    while i <= 100:
        sum += i
        i += 1
    print(f"1到100的和为{sum}")
  ~~~

---

### （二）for循环

#### ①基本语法

##### Ⅰ介绍

+ > `for`循环是一种“轮询机制”，对一批内容进行“逐个处理”

---

##### Ⅱ语法

+ ~~~python
    for 临时变量 in 待处理数据集:
      执行代码
  ~~~

---

##### Ⅲ临时变量作用域

+ 从规范上说，临时变量仅在循环内部起作用，**不建议在外部调用此循环变量**，尽管如此，在外部调用时编译器不会报错，但会弹出提示说明此处语法不规范，它的运行**结果如果输出的话，会是该循环变量最后一次被赋值的值**（我认为这是一种非常傻逼的操作，应该报错来减少`bug`的出现）。

---

##### Ⅳ待处理数据集

+ 该语法的含义是：对**待处理数据集**里面的数据挨个取出，每次循环将此数据赋给**临时变量**
+ 待处理数据集，严格来说称之为**序列类型**，其内容可以被一个个依次取出，包括
   1. 字符串
   2. 列表
   3. 元组
+ 理论上来说，`Python`的`for`循环不可能实现不限循环，因为*待处理数据集*不可能无限大

---

##### Ⅴelse子句

+ `python`的`while`和`for`循环都有一个`else`子句，该子句将在循环正常完成迭代之后执行，若循环过程中出现`break`、`return`或异常时，`else`子句便不会执行
+ 样例:
~~~python
  for i in range(1, 12):
      if i >= 12:
          break
  else:
      print('迭代正常完成')
~~~

---

#### ②range语句

##### Ⅰrange语句介绍

+` range`语句可以得到一个数字序列
+ `range`语句大部分情况用来配合`for`循环使用

---

##### Ⅱ使用

|格式|解释|
|---|---|
|`range(num)`|得到从`0`到`num-1`的跨度为`1`的数字序列|
|`range(num1,num2)`|得到从`num1`到`num2-1`的跨度为`1`的数字序列,前提是`num2>num1`|
|`range(num1,num2,step)`|得到从`num1`到\|`num2`\|`-1`的跨度为`1`的数字序列,`num2`可以小于`num1`，`step`可以为非`0`整数|

+ 样例:
  + 格式1例:

    ~~~python
      for x in range(10)
      print(x)
    ~~~

  + 格式2例:

    ~~~python
      for x in range(1,10)
      print(x)
    ~~~

  + 格式3例:

    ~~~python
    for x in range(1,-7,-2)
      print(x)
    ~~~

+ `num`、`num1`、`num2`只能输入整数，`step`只能输入非零整数。

---

### （三）嵌套循环

+ `while`循环嵌套:

+ ~~~python
    while 判断语句1:
      执行语句1
      while 判断语句2:
        执行语句2
  ~~~

+ for循环嵌套

+ ~~~python
    for 临时变量1 in 待处理数据集1:
      执行代码1
      for 临时变量2 in 待处理数据集2:
        执行代码2
  ~~~

---

### （四）continue与break

+ `continue`用于**中断**所在循环的当次执行，直接进入下一次循环
+ `break`用于**直接结束**所在循环
+ 二者用法与`C`基本相同，不做赘述。

---

## 六、数据容器

### （一）数据容器概览

#### ①定义

+ `Python`中的数据容器是一种**可以容纳多份数据**的数据类型，容纳的每一份数据称之为`1`个元素，每一个元素，可以是**任意类型的数据**，如字符串、数字、布尔等。
+ 数据容器根据其特点的不同，划分为下列五类：
  1. 列表(`list`)
  2. 元组(`tuple`)
  3. 字符串(`str`)
  4. 集合(`set`)
  5. 字典(`dict`)
+ 对于数据容器中的各元素，可以直接**用与元素数量相同的变量直接被赋值**,例:`a,b,c=[12,13,15.6]`

---

#### ②数据容器对比图

|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|列表|元组|字符串|集合|字典|
|:---:|:---:|:---:|:---:|:---:|:---:|
|**元素数量**|>|>|>|>|支持多个|
|**元素类型**|任意|任意|仅字符|不可变数据类型|`Key`为不可变数据类型，`Value`任意|
|**下标索引**|支持|支持|支持|不支持|不支持|
|**重复元素**|^|^|^|^|^|
|**可修改性**|可修改|>|不可修改|>|可修改|
|**数据有序性**|>|>|有序|无序|`3.7`前无序，`3.7`后有序|
|**使用场景**|处理可修改、可重复使用的一批数据|处理不可修改、可重复的一批数据|记录字符串时|处理不可重复的数据时|处理以`Key`检索`Value`的数据时|

---

#### ③数据容器通用操作

|操作/方法名称|格式|参数|说明|备注|返回类型|返回值|
|---|---|---|---|---|---|
|`len`|`len(数据容器)`|传入数据容器|求容器内元素个数|无|`int`|容器内元素个数|
|`max`|`max(数据容器)`|^|求容器内的最大元素|无|最大元素的数据类型|容器内的最大元素|
|`min`|`min(数据容器)`|^|求容器内的最小元素|无|最小元素的数据类型|容器内的最小元素|
|`list`|`list(数据容器)`|^|将容器转换为列表|无|`list`|转换后的列表对象|
|`tuple`|`tuple(数据容器)`|^|将容器转换为元组|无|`tuple`|转换后的元组对象|
|`str`|`str(数据容器)`|^|将容器转换为字符串|无|`str`|转换后的字符串对象|
|`set`|`set(数据容器)`|^|将容器转换为集合|无|`set`|转换后的集合对象|
|`dict`|`dict(数据容器)`|^|将容器转换为字典|虽然有这个方法，但是一般转换不了|`dict`|转换后的字典对象|
|`sorted`|`sorted(可迭代对象,key=None(可选),reverse=false(可选))`|`key`:默认为`None`,支持传入`lambda匿名函数`作为参数以指定根据哪一个参数排序<br>`reverse=false`:指定返回的对象内的元素以什么顺序排序，`True`为降序排序，`False`为升序排序，默认为升序|对数据容器中的元素排序|如果传入的数据容器为列表，默认将会根据键的值升序排序。如果使用`key=lambda匿名函数`,其会将列表的每一项键值对转换为长度为`2`的列表传入|`list`|以列表的形式返回排序后的结果|

|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|列表|元组|字符串|集合|字典|
|---|---|---|---|---|---|
|转化为列表|不变|元组的小括号变为中括号|字符串的每一个字符都作为列表的一个元素|集合的大括号变为中括号|字典的每一个`Key`都作为列表的一个元素，`Value`不会出现|
|转化为元组|列表的中括号变为小括号|不变|字符串的每一个字符都作为元组的一个元素|集合的大括号变为小括号|字典的每一个`Key`都作为元组的一个元素，`Value`不会出现|
|转化为字符串|正常情况|正常情况|正常情况|正常情况|`Key`、冒号和`Value`都会被保留|
|转化为集合|列表的中括号变为大括号，同时有序变为乱序|元组的小括号变为大括号，同时有序变为乱序|字符串的每一个字符都作为集合的一个元素，同时有序变为乱序|不变|字典的每一个`Key`都作为集合的一个元素，`Value`不会出现，为乱序|
|`sorted`函数|排序，以列表形式返回|排序，以列表形式返回|排序,以列表形式返回，排序后的字符串中的每个字符都作为列表的一个元素|排序，以列表形式返回|根据`Key`排序，以列表形式返回`Key`的排序结果|

+ `sorted`示例:

~~~python
  list1=[3.16,7,False]
  tuple1=(18,20.16,False)
  str1="edrhaw4y"
  set1={6,False,9+8j}
  dict1={
      "张三":True,
      "李四":"ooooo",
      "王五":[7.8885]
  }
  print(f"对列表排序，结果为:{sorted(list1)}")
  print(f"对元组排序，结果为:{sorted(tuple1)}")
  print(f"对字符串排序，结果为:{sorted(str1)}")
  print(f"对字典排序，结果为:{sorted(dict1)}")
  print(f"对集合排序，结果为:{sorted(set1)}")
  # 对于不同的数据类型来说，一般不可以比较大小
  # 从结果上来看，complex和bool类型之间貌似也不可以比较大小
~~~

### （二）list（列表）

#### ①列表特点

1. 可以容纳**多个**元素（上限为`2**63-1`个，可近似认为无穷多）
2. 可以容纳**不同类型**的元素（混装）
3. 数据是**有序**存储的（有下标序号）
4. 允许**重复**数据存在
5. 可以**修改**（增删改）

---

#### ②列表的定义

+ 列表的定义

~~~python
    # 定义变量
    #，定义列表用中括号，列表内的每一个元素，用逗号(英文)隔开
    List = [元素1,元素2,元素3，...]
    # 定义空列表
    List = []  #方法一
    List = list()  #方法二
~~~

---

#### ③列表的下标索引

+ 列表的下标索引可以从0开始，一直到列表长度`-1`，索引从大到小对应的值为列表从左到右存储的数据，为顺序
+ 列表的下标索引同样**可以为负数**，一直到-(列表长度),索引从大（`-1`）到小（-列表长度）对应的值为列表从右到左存储的数据，即逆序
+ 如果是嵌套列表，想要取数据的话，格式与`C`或`Java`的多维数组一样
+ 格式：
  + 若为单个列表，那么格式样例为`list[0]`
  + 若为嵌套列表，此处以嵌套了一层的列表为例，样例为：`list[0][0]`
+ 若超出列表范围，`Python`会报错

---

#### ④列表的常用方法

|方法名称|用法|解释|备注|返回类型|返回值|
|---|---|---|---|---|---|
|`index`|`列表.index(要搜索的数据)`|查找某元素在列表的下标索引，若没有找到报错“ValueError”|无|`int`|返回下标（若重复返回第一个元素的下标）|
|修改列表指定下标元素方法|`列表[下标]=数据`|这并不是一个方法，但为了省事我把它写在表里了，该方法可以用赋值运算符直接修改列表指定下标的元素值|无|不是方法|不是方法，无返回值|
|`insert`|`列表.insert(下标,要插入的数据)`|在列表的指定下标插入数据，并使列表中下标位置及其后的所有元素后移一位，为新元素腾出空间。若所写下标与列表本来的下标不连续，根据实践，该情况会使插入的数据被强制放到列表的第一位或最后一位|无|`NoneType`|`None`|
|`append`|`列表.append(要添加的数据)`|在列表的尾部添加一个元素|无|`NoneType`|`None`|
|`extend`|`列表.extend(容器)`|将容器的内容依次取出，追加到列表尾部|无|`NoneType`|`None`|
|用语句删除列表指定下标的元素|`del 列表[下标]`|这同样不是一个方法，但为了省事我把它写在表里了，该方法可以利用`Python`的语法直接删除列表指定下标元素|无|不是方法|不是方法，无返回值|
|`pop`|`列表.pop(下标)`|通过`Python`的内置方法取出列表指定下标元素并将其从列表中移除|无|与取出的元素类型一致|列表的指定下标元素|
|`remove`|`列表.remove(要删除的数据)`|该方法可以从前往后寻找，将找到的第一个与之匹配的元素删除，若找不到，报错“`ValueError`”|无|`NoneType`|`None`|
|`clear`|`列表.clear()`|清空列表|无|`NoneType`|`None`|
|`count`|`列表.count(元素)`|查找列表中指定元素的出现次数|无|`int`|元素出现次数|
|`len`|`len(列表)`|求列表中包含的元素总数（列表长度）|无|`int`|列表长度|
|`sort`|`列表.sort(key=选择排序依据的函数,reverse=True/False)`|对列表进行可自定义的排序|弥补了`sorted`函数无法对嵌套的列表排序的缺陷|`list`|

---

#### ⑤需要解释的方法

##### Ⅰsort方法

~~~python
  list1=[("张三",20),("李四",15),("王五",18),("赵六",42)]
  # 调用排序函数，使用了lambda语法传入了一个临时函数用来返回排序所依据的数据，reverse=False来设置不逆序，即结果为升序排序
  list1.sort(key=lambda my_list:my_list[1],reverse=False)
  print(list1)
~~~

### （三）tuple（元组）

#### ①元组特点

+ 元组最大的特点是**无法修改其元素**，其它特点与`list`相同
+ 但如果元组里面包含一个`list`（列表），那么此列表中的元素是可以修改的

---

#### ①元组定义

+ ~~~python
    #定义变量：定义元组使用小括号，其中的元素用逗号隔开
    变量名称=(元素1、元素2、元素3...)
    #定义空元组
    变量名称=()  #方式一
    变量名称=tuple()  #方式二
  ~~~

+ 如果要定义只有一个元素的元组，**应该在元素之后写上一个逗号**，否则生成的数据类型不是元组而是存入的元素的数据类型

+ ~~~python
    Tuple1=(1)
    Tuple2=(1,)
    print(f"Tuple1的类型是{type(Tuple1)},Tuple2的类型是{type(Tuple2)}")
  ~~~

---

#### ②元组的常用方法

|方法名称|用法|解释|返回值|
|---|---|---|---|
|`index`|`元组.index(要搜索的数据)`|查找某元素在元组的下标索引，若没有找到报错“`ValueError`”|返回下标（若重复返回第一个元素的下标）|
|`count`|`元组.count(元素)`|查找元组中指定元素的出现次数|元素出现次数|
|`len`|`len(元组)`|求元组中包含的元素总数（元组长度）|元组长度|

---

### （四）String（字符串）

#### ①字符串特点

+ 与元组一样，字符串本身**不可以修改**（如:`字符串.pop()、字符串.remove()、字符串.append()、del 字符串[下标]`），如果执意要修改,只会得到一个新字符串。

---

#### ②定义方法

+ 字符串方法有三种定义方法：单引号定义`eee`、双引号定义`"eee"`、三个双引号定义`"""eee"""`
+ 引号的嵌套：
  + 使用双引号定义支持字符串中含有单引号
  + 使用单引号定义支持在字符串中含有双引号
  + 使用转义字符`\`转义内部的单、双引号\

---

#### ③引号的嵌套

+ 引号的嵌套：
  + 使用双引号定义支持字符串中含有单引号
  + 使用单引号定义支持在字符串中含有双引号
  + 使用转义字符`\`转义内部的单、双引号

---

#### ④字符串的拼接

+ 用`+`号来进行字符串拼接
+ 例:

+ ~~~python
  name="李子轩"
  print("我的名字是："+name)
  ~~~

+ `+`号仅能拼接字符串，**不能将不同类型的数据拼接起来**，如果进行此操作，编译器会报错

---

#### ⑤字符串的下标索引和比较
+ 字符串同其它数据容器一样，也支持通过**下标索引**的方式取值
+ 字符串的比较是**从左至右的字符依次比较**，比较期间，如果有一位大，那么将直接返回结果，后续便不用比较了
+ 不是很清楚字符之间是根据什么比较的，目前先默认为根据`Unicode`码比较

---

#### ⑥字符串常用操作

|操作名称|格式|说明|备注|返回类型|
|---|---|---|---|---|
|取值操作|`字符串[下标]`|根据下标索引取出特定位置字符|无|`String`|
|`index`|`字符串.index(元素)`|查询找到的第一个匹配元素的下标|无|`int`|
|`replace`|`字符串.replace(字符串1，字符串2)`|将字符串内的全部的字符串1修改为字符串2，生成一个新字符串并返回|**不会修改原字符串**，而是会返回一个新字符串|`String`|
|`split`|`字符串.split(分割依据（字符串）)`|根据传入的字符串分割原字符串，生成一个新的列表并返回|^|`list`|
|`strip`|`字符串.strip(字符串（可以不写）)`|移除首尾的指定字符串，如果不写，默认移除空格、制表符和换行符|^|`String`|
|`count`|`字符串.count(字符串)`|统计指定字符串的出现次数|无|`int`|
|计算字符串长度|`len(字符串)`|计算字符串长度|无|`int`|
|`ord`|`ord(字符)`|得到指定字符的ascⅡ码值|该函数仅支持传入一个字符|`int`|
|`chr`|`chr(字符)`|将指定ascⅡ码值转换为字符|该函数仅支持传入合法ascⅡ码值|`String`|

#### ⑦需要解释的操作

##### Ⅰstrip方法

+ 该方法可以**去掉首位的指定字符串**并**返回一个新的字符串**回去
+ 示例:

+ ~~~python
  str="1222234516111221"
  str1=str.strip("162")
  print(f"结果为:{str1},类型为{type(str)}")
  """
  其结果为'345'，因为该方法的作用原理是从字符串首尾开始，每次都判断str中的字符是否被传入的字符串包括
  如果是，那么查找下一个是否被包括
  如果不是，那么便不再进行去除
  注意：首尾都要进行匹配
  """
  str="  Hello World  "
  print(f"结果为{str.strip()},类型为{type(str)}")
  """
  如果strip没有被传入任何参数，那么他将默认移除首尾的空格、制表符和换行符
  """
  ~~~

---

### （五）序列

#### ①序列的定义

> 序列是指：内容连续、有序，可使用下标索引的一类数据容器

+ **列表**、**元组**、**字符串**均可视为序列

---

#### ②序列常用操作

##### Ⅰ一览表

---

##### Ⅱ切片操作

+ 切片即从一个序列中，取出一个子序列
+ 语法：`序列[起始下标:结束下标:步长]`
  + 改语法表示从起始下标开始，依据步长依次取出元素，直至到达或超出结束下标结束，得到一个**新的序列**
  + 起始下标表示从何处开始，可以留空，留空表示从头开始
  + 结束下标表示到何处结束（得到的子序列元素不包括结束下标的元素，只会包括结束下标对应元素之前的），可以留空，留空表示直到结尾
  + 步长表示依次取元素的间隔
    + 步长为`1`表示：一个一个取，不跳
    + 步长为`2`表示：隔一个元素取一个
    + 步长为`n`表示，隔`n-1`个元素取一个
    + 步长为负数表示反向取（此时**起始下标应大于结束下标**）
+ 示例:

+ ~~~python
  str1="  Hello World  "
  str2=str1[:]  #从字符串开始至结束，将字符一个一个取出来得到一个新的字符串
  print(f"一个一个取{str2}")
  str2=str1[3::1]  #从字符串下标为3的元素开始一个一个取出来得到新字符串
  print(f"从下标为3开始一个一个取{str2}")
  str2=str1[:5]  #从字符串开始到下标为5的元素，一个一个取出来得到新字符串
  print(f"一个一个取，取到下标为5的字符串{str2}")
  str2=str1[::-1]  #从字符串结尾至开始，将字符串一个一个取出来得到新字符串
  print(f"逆序字符串{str2}")
  str2=str1[9:2:-2]  #从字符串下标为9的元素开始，到下标为2的元素结束，隔一个取一个
  print(f"从下标为9到下标为2，隔一个取一个{str2}")
  ~~~

---

### （六）集合

#### ①集合的特点

+ **无重复**元素
+ **可修改**
+ **无序**
+ 只能存储可哈希(即不可变)的数据类型
  + 数字类型(`Number`),包括`int`、`float`、`complex`(复数)、`bool`
  + 元组(`tuple`)
  + 字符串(`str`)
  + 空值(`NoneType`)
+ 支持**多个**数据
+ **仅能用`for`循环遍历**（因为集合无序，无法使用下标索引取值）

---

#### ②集合的定义

+ 集合定义时，要用**大括号**括起来，元素之间使用逗号隔开

+ ~~~python
    #定义变量
    set1={1,True,3.14,6+7j,(5,),"aaa"}
    print(f"输出集合set1{set1}")  #虽然定义了6个元素，实际输出的时候只有5个，因为True的本质是数字1

    #定义空集合
    set1=set()
  ~~~

---

#### ③集合的常用操作

|操作/方法 名称|格式|说明|备注|返回类型|
|---|---|---|---|---|
|`add`|`集合.add(元素)`|向集合中添加一个元素|无|`NoneType`|
|`remove`|`集合.remove(元素)`|移除集合中的指定元素|无|`NoneType`|
|`pop`|`集合.pop()`|随机取出一个集合元素，并将此元素从集合中移除|对集合本身有修改|与取出的集合元素类型一致|
|`difference`|`集合1.difference(集合2)`|返回集合1中有的而集合2中没有的元素|返回值作为一个新的集合返回1集合1与集合2不会发生改变|`set`|
|`difference_update`|`集合1.difference_update(集合2)`|将集合1中存在于集合2中的元素删除|集合1被修改，集合2不变|`NoneType`|
|`union`|`集合1.union(集合2)`|合并两个集合中的全部元素，生成一个新的集合并返回|原有的两个集合内容不变|`set`|
|`clear`|`集合.clear()`|将集合清空|无|`NoneType`|
|`len`|`len(集合)`|求集合中的元素数量/集合长度|无|`int`|

---

### （七）字典

#### ①字典的特点

+ 字典拥有独特的`Key`和`Value`机制，通过`Key`可以找到其`Value`，即字典的每一份数据都是`KeyValue`键值对
+ 字典中的`Key`与`Value`都可以支持多种类型（Key不能为可变的数据类型，如`list`(列表)、`dict`(字典)、`set`(集合)等）
+ 字典是**乱序**的，因此它与集合一样，不支持下标索引，但它可以通过特定的`Key`找到特定的`Value`
+ 字典可以存储**多组**数据，且可以**嵌套**
+ 字典中**不能有重复数据**，如果有，前面的数据会被后面的重复数据覆盖，最后的结果依然是没有重复的数据
+ 元素**可以修改**

---

#### ②字典的定义

+ 字典定义时，与集合一样，同样需要用**大括号**，之间的各元素用逗号隔开
+ 具体格式如下:

~~~python
  #定义变量
  dict1={"李子轩":{"语文":15,"数学":20,"英语":5}}
  print(f"dict1['李子轩']")  #使用Key得到Value。字典不能使用下标索引得到元素的值
  #定义空字典
  dict1={}  #空的大括号被视为空字典，因此集合不能是用空大括号来表示空集合
  dict1=dict()
~~~

---

#### ③字典的常用操作

|操作/方法 名称|格式|说明|备注|返回类型|
|---|---|---|---|---|
|添加/更新操作|`字典[Key]=Value`|如果`Key`不在字典中，那么添加一个进去，如果在字典中，那么修改对应的`Value`值|无|语句无返回值|
|`pop`|`字典.pop(Key)`|取出`Key`对应的`Value`并在字典中删除该`Key`对应的键值对|无|`Key`对应的`Value`的数据类型|
|删除元素|`del 字典[Key]`|删除字典中`Key`对应的键值对|无|语句无返回类型|
|`clear`|`字典.clear()`|清空字典|无|`NoneType`|
|`keys`|`字典.keys()`|以列表的形式返回字典的全部`Key`|无|`list`|
|`values`|`字典.values()`|以列表形式返回字典全部的`value`|无|`list`|
|`items`|`字典.items()`|以列表承载元组的形式返回字典全部的键值对|无|`list`|
|`len`|`len(字典)`|返回字典的长度/字典所包含的键值对数量|无|`int`|
|字典遍历|`for 临时变量 in 字典:`|字典的遍历|无|语句无返回值|

---

## 七、文件操作

### （一）文件编码

> 编码是一种规则集合，记录了内容和二进制间进行相互转换的逻辑
> 编码技术即：翻译的规则，记录了如何将内容翻译成二进制，以及如何将二进制翻译回可识别内容
+ `UTF-8`是目前**全球通用**的编码格式

---

### （二）文件的读取

#### ①函数表

|操作分类|操作/方法 名称|格式|说明|备注|返回类型|返回值|
|---|---|---|---|---|---|---|
|打开文件|`open`|（此处为一般格式）`open(文件路径,文件打开模式,编码格式)`|打开文件，并返回对应的文件对象|无|`_io.TextIOWrapper`|打开的文件对象|
|读取文件|`read`|`文件对象.read(要读取的字符数)`|在文件中读取指定字符数的字符，如果不写默认全部读取|若写有多个读取文件的操作代码，那么本次操作将从上次操作结束的地方开始|`str`|读取后的字符串|
|^|`readlines`|`文件对象.readlines()`|将文件中的数据以行为单位存入列表中，并返回列表对象|^|`list`|列表对象|
|^|`readline`|`文件对象.readline()`|读取文件中的一行数据|^|`str`|读取后的字符串|
|关闭文件|文件关闭|`文件对象.close()`|将文件关闭，结束`Python`程序对文件的占用|无|`NoneType`|`None`|

|文件打开模式|描述|
|---|---|
|`r`|以**只读**方式打开文件,文件的指针将会放在文件的开头，这是默认模式。|
|`w`|打开一个文件**只用于写入**，如果该文件已存在则打开文件，并从头开始编辑，原有内容将会被删除；如果该文件不存在，那么创建一个新文件|
|`a`|打开一个文件**用于追加**，如果该文件已存在，新的内容将会被写入到已有内容之后；如果该文件不存在，创建新文件进行写入|

---

#### ②部分操作详解

##### Ⅰopen方法

+ `open`方法的具体定义为`open(file, mode='r', buffering=None, encoding=None, errors=None, newline=None, closefd=True)`，常用的操作为向函数传入`file`(文件路径)、`mode`(文件打开模式)和`encoding`(文件编码)三个变量
+ `open`方法将返回一个打开后文件的对象，其类型为"`_io.TextIOWrapper`"
+ 样例:
~~~python
  file=open("E:/文件.txt","r",encoding="UTF-8")
  print(f"{type(file),file}")
~~~

---

##### Ⅱread、readlines、readline方法

+ 三种方法的具体使用如下
  + `read`方法通过传入一个指定数，指针将会**从最后的结束位置开始读取指定数个字符**，并返回这些字符组成的字符串；如果不写或传入负数，默认读取全部内容 
  + `readlines`方法通过传入一个指定数来**指定要读取的最大字符数**，如果该字符数大于第`n`行字符数且小于第`n+1`行字符数，将返回全部的`n+1`行内容组成的列表对象；如果传入的参数为负数或不写参数，默认读取全部内容
  + `readline`方法通过传入一个指定数来**指定要读取的本行的最大字符数**，如果字符数大于该行全部字符数，依旧返回一行的全部内容；如果不写或传入负数，默认读取全部内容
+ 若写有多个读取文件的操作代码，那么本次操作将从上次操作结束的地方开始
+ 样例:
~~~python
  file=open("E:/文件.txt","r",encoding="UTF-8")
  print(f"{file.read(10),file.readline(100),file.readlines(90)}")
~~~

---

##### Ⅲfor循环遍历文件

+ 样例:
~~~python
  for data in file:
    print(f"{data}")
~~~

##### Ⅳclose方法与with open语句

+ `close`方法可以解除`Python`程序对于文件的占用
+ `with open`语句格式为:
~~~python
  with open("E:/文件.txt","r",encoding="UTF-8") as 变量名:
    语句
~~~
+ `with open`语句内的代码执行语句结束后，会**自动解除**`Python`对文件的占用
+ 样例:
~~~python
with open("E:/文件.txt","r",encoding="UTF-8") as file:
    print(f"有{file.read().split().count('111')}个") #统计文件内共有多少个'111'的字符串
~~~

---

### （三）文件的写入

|方法|描述|备注|
|---|---|---|
|`write`|将输入的内容存入内存|只调用`write`方法**不会**直接将内容写到文件中去|
|`flush`|刷新文件，同时将内存中保存的要写入文件的内容写入到文件中去|**调用该方法才可以成功将存储在内存中的待写入数据存入文件**|
|`close`|关闭文件|该方法内置了`flush`方法的功能，因此不写`flush`方法仅写`close`方法也能将内存中的待写入数据写入文件|

+ 文件可以通过`write`方法将输入的内容**存入内存**
+ 通过`flush`方法一次性地将内存中的待写入数据**存入到文件中去**
+ **`close`方法内置了`flush`方法的内容**
+ 样例:
~~~python
  with open("E:/文件.txt","a",encoding="UTF-8") as file:
      file.write("哦哦哦哦哦")
      file.flush()
~~~

---

## 八、异常处理

### （一）Python异常的捕获

#### ①格式

~~~python
  try:
    可能出现异常的代码
  except 异常类型 as 临时变量:
    处理异常的代码
  # 此处以下的代码不是必须写的
  else:
    未出现异常时，要执行的代码
  finally:
    不管是否出现异常，都要执行的代码
~~~

---

#### ②单异常的捕获

+ 样例：
~~~python
  try:
    1/0
  except ZeroDivisionError as e:
    print(e)

~~~

---

#### ③多异常的捕获

+ 样例:
~~~python
  try:
    1/0
    print(name)
  except (ZeroDivisionError,NameError) as e:
    print(e)
~~~

---

#### ④任意异常的捕获

+ 样例:
~~~python
  try:
    1/0
  except:
    print("出现异常")

  # 方法二
  try:
    print(name)
  except Exception as e:
    print(e)
~~~

---

### （二）异常的传递性

+ 如果一个异常出现，它将**从底层一直向上传递**，从而使整个与此异常相关的代码都出现异常
+ 样例:
~~~python
  def func1():
      print("函数1开始执行")
      num=1/0  #在此处出现异常
      print("函数1结束执行")


  def func2():
      print("函数2开始执行")
      func1()  #异常会使此处也出现异常
      print("函数2执行结束")


  def func3():
      func2()#异常会使此处也出现异常

  func3()  #异常会使此处也出现异常
~~~
+ 可以根据异常的传递性，在出现异常的各处进行异常捕获和处理皆可
~~~python
  try:
    func3()
  except Exception as e:
    print(e)
~~~

---

# 第二部分：函数

## 一、函数基础

### （一）函数定义

#### ①定义格式

> 函数是**组织好**的，**可重复使用**的，用来**实现特定功能**的代码段

+ 函数的定义格式如下：

+ ~~~python
    def 函数名(变量):
      函数体
      return 结果
  ~~~

+ 其中，`return` 可以不写(不写也有返回值，返回值为`None`)，传入的变量也可以没有

---

#### ②None关键字

+ 在`Python`中，`None`用于表示空、无意义，这是一种特殊的字面量，其数据类型为`NoneType`
+ 在函数没有写`return`语句时，函数会自动返回`None`
+ `None`在`if`语句中相当于`False`
+ 数据在初始化时可以赋空值`None`

---

#### ③局部、全局变量和global关键字

~~~python
  num=1
  def function1():
    global num
    num=10
    print(num)
  def function2(x):
    print(num+x)
  function1()
  function2(1)
  print(num)
~~~

+ 以上代码中，`x`为局部变量，`num`为全局变量
+ 全局变量只需要在函数体外定义即可，函数体可以调用该全局变量进行一些运算。
+ 如果想要通过函数对全局变量进行修改，需要先像`function1()`函数那样写一句`global 全局变量名`,然后再对全局变量进行赋值操作才行。
+ 如果不使用`global`关键字而在函数体中对全局变量进行修改，该情况会被视为在函数体中定义了一个新的、与全局变量名字一样的**局部变量**

---


## 二、Python基本函数

### （一）基本函数一览表

|函数分类|函数名|格式|描述|备注|返回类型|返回值|
|---|---|---|---|---|---|---|
|输入/输出函数|`print`|`print(要输出的数据)`|输出信息|无|`NoneType`|`None`|
|^|`input`|`input(提示)`|输入数据|无|`str`|字符串形式的输入的数据|
|类型函数|`type`|`type(数据)`|返回传入数据的数据类型|无|依据传入的数据而定|传入数据的数据类型|
|^|`id`|`id(arg)`|查看变量的`id`值|若两个变量(`a`与`b`)的`id`相同，则`a is b`的结果为`True`|`int`|变量`id`值|
|^|`str`|`str(数据)`|将数据转换为字符串形式|无|`str`|转换后的结果|
|^|`int`|`int(data,base)`|将浮点数或字符串转换为整数形式|1.若不写`base`，则**默认转换数据为十进制数**<br>2.将浮点数转换为整数时，会**取整数部分**<br>3.**`int`函数无法将浮点数字符串转换为整数**|`int`|转换后的结果|
|^|`float`|`float(数据)`|将数据转换为浮点数形式|无|`float`|转换后的结果|
|^|`bool`|`bool(数据)`|将任意可被解析为逻辑值的对象值转换为布尔值|无|`bool`|转换后的结果|
|数值处理函数|`round`|`round(number,ndigits)`|用于对浮点数进行四舍五入操作，并返回最接近的整数或指定小数位数的数值|1.`number`是用来处理的数据，`ndigits`是要保留的小数位数<br>2.如果不写`ndigits`值或将该值设为空，那么函数会返回最接近输入值的整数<br>3.进位参考`python`的[末位取舍算法](#python_carry)|类型取决于返回结果|操作后的结果|
|^|`eval`|`eval('代码')`|`eval`函数会将两边的引号去掉，并将中间的内容当作`python`代码执行，并返回执行结果。|1.**因为它可以去掉字符串的引号，因此此处可以用来将input函数的返回的数字字符串转换为数值**<br>2.`eval()`函数还**可以把用逗号分隔的多个数值类型的字符串转换为一个元素为数值类型的元组**|依据返回值结果而定|数值或元组|
|^|`map`|`map(function,iterable)`|对可迭代对象中的每个元素执行指定的函数操作，并返回一个包含结果的迭代器|1.如果需要输出结果，可以**使用与返回结果包含的元素数量相同的变量一个一个接收(`a,b,c=map(int,[2,True,3.6])`)并输出(`print(a,b,c)`)**，也可以**使用数据容器的转换函数输出(`print(list(map(int,[3.26,5.18])))`)**<br>2.**第一个参数需要传入函数名**，可以是lambda匿名函数，也可以是自定义函数或`python`内置函数，**只需要将函数名传入即可**，**第二个参数传入待处理的可迭代对象**|`map`|迭代器|
|^|`max`|`max(arg1,arg2,arg3....)`和`max(iterable)`|从多个参数或一个可迭代对象中返回其最大值|有多个最大值时返回第一个|依据返回值结果而定|最大值|
|^|`min`|`min(arg1,arg2,arg3....)`和`min(iterable)`|从多个参数或一个可迭代对象中返回其最小值|有多个最小值时返回第一个|^|最小值|
|数学运算函数|`abs`|`abs(data)`|求整数或浮点数的绝对值|**传入的参数为复数时返回值为复数的模**|`int`或`float`|绝对值|
|^|`divmod`|`divmod(number1,number2)`|以元组形式返回`number1//number2`和`number1%number2`的值|无|元组|`number1//number2`和`number1%number2`的值|
|^|`pow`|`pow(x,y,z)`|返回(`x^y`)，当`z`存在时，返回(`x^y%z`)|该函数比先求x的y次幂，再对z取余**效率更高**,因为该函数的取幂和取余操作是同时进行的|`number`|若写z，则返回(`x^y%z`),若不写则返回(`x^y`)|
|^|`sum`|`sum(iterable,start)`|计算输入的可迭代对象所有元素的和|`start`表示和的默认起始值，不写默认为`0`|`number`|输入的可迭代对象所有元素的和|

---

### （二）基本函数详解

#### ①print()函数

##### Ⅰ基本输出格式

+ 用来输出信息
+ 示例如下:

+ ~~~python
    a="Hello World"
    print("你好世界",a,111,11.14)

    #输出不换行
    print("Hello World",end='')
  ~~~

---

##### Ⅱ对字符串的输出格式化

###### <一>占位拼接字符串法

+ 该方法与`C`语言通过`printf`输出不同类型的数据类似
+ 格式:`"xxx%s(将数据转化为字符串类型)%d(将数据转化为整数型)%f(默认将数据转化为6位小数)" %(表示占位) (待占位数据1，带占位数据2，带占位数据3)`
+ 对于要占位两个及以上的字符串，数据需要用括号括起来，每个数据需要用逗号隔开；如果仅有一个要占位的，那么不需要用括号，也不需要用逗号隔开。
+ 例:

+ ~~~python
  general1 = "我的名字是"
  name = "李子轩"
  general2 = "，今年"
  age = 20
  general3 = "岁了，有"
  money = 300.1275286
  end = "元，很穷"
  print("%s %s %s %d %s %f %s" % (general1, name, general2, age, general3, money, end))
  ~~~

---

###### <二>数据类型占位符表

|占位符格式|描述|
|---|---|
|`%c`|格式化字符及其`ASCII`码|
|`%s`|格式化字符串|
|`%d`|格式化整数|
|`%f`|格式化浮点数，可指定小数后精度|
|`%e`|用科学计数法格式化浮点数|
|`%E`|作用同`%e`，用科学计数法格式化浮点数|
|`%u`|格式化无符号整型|
|`%o`|格式化无符号八进制数|
|`%x`|格式化无符号十六进制数|
|`%X`|格式化无符号十六进制数（大写）|
|`%g`|`%f`和`%e`的简写|
|`%G`|`%f`和`%E`的简写|
|`%p`|用十六进制数格式化变量的地址|

---

###### <三>格式化精度控制

+ 精度控制主要作用于数字类型的数据，其格式为`%m.n`
+ 格式的详细解释
  + `m`负责控制数据的宽度，如果**设置的宽度不足会导致限制无效**
    + 例：

    + ~~~python
      money1=1.23456789
      money2=16685
      print("我有%12f元钱"%money1)
      print("我有%8d元钱"%money2)
      ~~~

  + `n`负责控制小数点位数
  + 例：

  + ~~~python
      money=1.23456789
      print("我有%12.4f元钱"%money)
      print("我有%.4f元钱"%money)
    ~~~
---

###### <四>字符串快速格式化

+ 格式：`print(f"xxx{变量名/数据}")`
+ 特点：
  1. 适用于**全部**数据类型
  2. **不能**作精度限制
  3. 便于**快速**输出字符串
+ 例：

  + ~~~python
      name="李子轩"
      age=20
      money=13.14
      print(f"我叫{name}，今年{age}岁了，有{money}块钱，穷")
    ~~~

+ 快速格式化使用`:m.n`进行精度控制
+ 例:

~~~python
  import math
  print(f"{math.pi:>5.6f}") 
  # 此处的意思是输出时至少占用5个字符的空间，并保留小数点后六位，四舍五入。如果数值长度比限制的数量还长，因为是至少占用的空间，因此会按照长的一方进行显示
  # 如果符号为小于号，表示左对齐，^符号表示居中对齐，大于号表示右对齐
~~~

+ 快速格式化与占位拼接字符串法貌似可以一起用:
+ 例:

~~~python
  pi = 3.14159265358979
  a = input()
  print(f"圆周率值为：%5.{a}f" % pi)  
  # 含义:至少占用5个字符空间，保留小数点位数取决于a的值，四舍五入
~~~
---

###### <六>表达式格式化

+ 表达式：`一个具有明确结果的代码语句`
+ 格式：将前面的格式化示例的变量名或数据变成表达式即可，其写法与`C`基本类似
+ 例：

+ ~~~python
    print("我的年龄是:%d,有%.2f块钱" % ((18 + 2), (15.23 + 4)))
  ~~~

---

#### ②input()函数

+ `input()`函数用来输入数据，并兼顾提示的作用
+ `input()`函数的返回值是`String`类型，**如果返回值与想要的数据类型不匹配，需要进行类型转换**
+ 示例:

+ ~~~python
    age = input("请告诉我你的年龄\n")
    print(f"你的年龄为{age}岁,input返回值类型为{type(age)}")
  ~~~

---

#### ③数值处理函数

##### Ⅰround()函数

+ `round(number,n)`函数可以返回浮点数`number`保留`n`位小数的形式，`n`为整数，默认为`0`
+ 当参数`n`省略不写时，即默认为`0`,函数会返回最接近输入数字的整数
+ 当写了参数`n`时，函数会根据`python`的[末位取舍算法](#python_carry)决定小数的进位:
+ 注意:
> 1. 当`n`**超过**小数位数时，返回该数的**最短表示**
> 2. **绝大多数浮点数无法精确转换为二进制，因此会导致部分数字取舍与期望不符**
+ 样例:
~~~python
  print(round(3.1425, 3))  # 绝大多数浮点数无法精确转换为二进制，因此会导致部分数字取舍与期望不符.此处理论值应为3.142,实际为3.143
  print(round(3.1, 7))  # 当n超过小数位数时，返回该数的最短表示
  print(round(3.5))  # 末位以后没有值，前一位值为奇数，进位
  print(round(2.5))  # 末位以后没有值，前一位为偶数，不进位
  print(round(3.12500000001, 2))  # 末位以后有非0值，进位
  print(round(3.1769))  # 未指定n，返回最接近的整数，取最接近整数时也会参考末位取舍算法
~~~

##### Ⅱint()函数

+ `int(x,base=10)`函数可以将**浮点数或整形字符串**转换为整数类型。
+ 当写了`base`值或者传入的`x`值为非数字时，`x`必须是一个**整型的字符串**,此时`base`等于告诉函数传入的`x`值是几进制的
+ 注意:
> 1. `base`的值可以取`0`、`2~36`之间的整数，当`base`值为`0`时，函数会根据**字符串前面的进制引导符**确定该数的进制
> 2. **该函数不能将浮点数字符串转换为整数**
> 3. 该函数将浮点数转换为整数实际上就是**直接取小数的整数部分**
+ 样例:
~~~python
  a = 5.7
  print(int(a))  # 直接取小数的整数部分
  a = '10011'
  print(int(a, base=2))
  print(int(a, 2))  # 这两种写法实际上是一样的
  b = "3.567"
  print(int(b))  # 无法将浮点字符串转换为整数
~~~

---

##### Ⅲeval()函数

+ `eval()`函数在此处用来将`input()`函数返回的数字字符串转换为数字
+ 注意:
> + `eval()`函数也可以将用逗号分隔的多个数字字符串转换成一个元素为数字类型的元组(`tuple`)
+ 样例:
~~~python
  print(eval('12,3.6,5.7'))
  print(eval('6.3'))
  a,b,c=eval('12,3.65,True') #eval可以将用逗号分隔的多个数字字符串转换成一个元素为数字类型的元组，由于元组有三个元素，因此将内部的元素依次赋值给变量a、b、c
  print(a,b,c)
~~~

---



## 三、函数进阶

### （一）函数多返回值

+ `Python`中的函数可以有多个返回值
+ 具体格式为`return 返回值1,返回值2,返回值3,....`
+ 函数有多个返回值时，需要用对应数量的变量来接收:`变量1,变量2,变量3,.....=函数名(参数)`
+ 根据实践，函数有多个返回值时，实际上是将这些返回值作为`tuple`（元组）返回的
+ 例：
~~~python
def function():
  return 1,[True,6+7j,16.54],{"张三":1,"李四":"km"}
a,b,c=function()
print(f"{a}{b}{c}{function()}")
~~~

---

### （二）函数多种参数使用形式

#### ①位置参数

+ 位置参数即按照函数参数的定义顺序来依次像函数传递符合要求的参数
+ 该方式与`C`和`Java`传参的方式是一样的，也和之前写的函数基础所要求的是一样的，此处不予赘述

---

#### ②关键字参数

+ 关键字参数可以使用"**键=值**"的操作来传递参数，且可以**不按顺序**传递参数，也可以一半按位置参数的规范传递，一般按关键字参数的方式传递
+ 样例：
~~~python
def function(name, age, money, location):
    print(f"名字是{name},年龄是{age}岁,有{money}元钱,家在{location}")


function(age=20, location="保定市", money=96.12, name="李子轩")  #不按顺序，用关键字参数的形式传参
function("李子轩", 20, location="保定市", money=156.27)  #半位置半关键字传参
~~~

---

#### ③缺省参数

+ 缺省参数通过在定义函数参数时便使用"**参数名=值**"的形式来默认指定该参数的值
+ 根据语法，缺省参数定义**必须写在参数定义的最后面**，否则会报错
+ 写了缺省参数的话，在传参时不传该参数也没有问题
  + **不传参**的话，会默认使用函数定义时写的参数**默认值**
  + 传参会将默认值改为传入的值
+ 样例:
~~~python
  # 缺省参数必须写在参数定义的最后面
  def function(name, age, money, location="保定市", like="摆烂"):
      print(f"名字是{name},年龄是{age}岁,有{money}元钱,家在{location},喜欢{like}")


  function(age=20, location="定兴县", money=96.12, name="李子轩", like="睡觉")  #传入参数，输出结果与传入参数一致，而并非默认参数值
  function("李子轩", 20, money=156.27)  #不传入参数，输出默认参数值
~~~

---

#### ④不定长参数

##### Ⅰ位置不定长传递

+ 位置不定长传递是函数在定义参数时，仅需写`*args`便可以自动接收**无限制数量**的参数
+ 这些参数会被转换成**tuple(元组)的一个个元素**存储在`*args`中
+ 该方法仅能向函数传递单纯的数据，**不能**以"键=值"的形式向函数传参
+ 样例:
~~~python
  def function(*args):
      print(f"类型为{type(args)},值为{args}")


  function(20, "定兴县", 96.12, "李子轩", "睡觉")
  function("李子轩", 20, 156.27)
~~~

---

##### Ⅱ关键字不定长传递

+ 关键字不定长传递是函数在定义参数时，仅需写`**kwargs`(即keyword args)，便可以自动接收**无限制数量**的"键=值"形式的参数
+ 这些参数会被转换成**dict(字典)的一个个元素**存储在`**kwargs`中
+ 该方法仅能向函数传递"键=值"型的参数，不能以纯数据的形式向函数传参
+ 样例
~~~python
  def function(**kwargs):
      print(f"类型为{type(kwargs)},值为{kwargs}")


  function(age=20, location="定兴县", money=96.12, name="李子轩", like="睡觉")
  function(name="李子轩", age=20, money=156.27)
~~~

---

### （三）函数作为参数传递

+ 在`Python`中，函数是可以作为参数传递到函数中去被使用的
+ 将函数传入的作用在于：**传入的是计算逻辑**，而不同于以往的参数传入的是数据
+ 函数如果作为参数传递，那么它的类型为"`function`"
+ 样例:
~~~python
  def function(x, y):
      return x+y

  # 该函数的参数x即为定义的函数function"""
  def function1(x, a, b):
      y=x(a,b)
      print(f"传入的函数的类型是{type(x)}")  #由print输出的结果可知，函数类型为"function"
      return y


  m=function1(function, 2, 3)
  print(m)
~~~

---

### （四）lambda匿名函数

+ 在函数的定义中
  + 使用`def`语法定义的函数有名字、可重复使用
  + 而使用`lambda`语法定义的函数**没有名字且仅能临时使用一次**
+ 语法:`lambda 参数:函数体(仅能写一行代码)`
+ 在`lambda`匿名函数的语法中，该函数没有名称，且**函数体仅能为一行代码**，这一行代码可以省略`return`，因为**该语法默认将函数体执行得到的结果`return`返回**
+ `kambda`函数可以使用它所在的作用域的变量，如:在主函数作用范围内使用主函数的变量
+ 样例:
~~~python
  def function1(x, a, b):
      y=x(a,b)  # 这个x的意思是lambda匿名函数对象，即调用该函数对象并传入所需的两个参数来得到结果
      print(f"传入的函数的类型是{type(x)}")
      return y


  m=function1(lambda x, y : x+y, 2, 3)

  print(m)
~~~

---

# 第三部分 面向对象

## 一、类

### （一）类的定义
+ 在`Python`中，通过
~~~python
  class 类名:
    类的属性
    类的行为
~~~
这种方法来定义类

---

### （二）类方法

#### ①定义

+ 在类中定义的函数即为类方法
+ 与在类外面定义的函数不同，类方法需要**在传入的参数开头额外写一个必须的参数`self`才能正确定义**
+ 其定义格式为:`def 方法名(self,参数1,参数2,....):`
+ 在传参时，`Python`会自动向`self`的参数位置传入对应参数(即此方法所在类的类对象),因此传入参数时无视掉`self`就好，但在**定义时是必须写**的

#### ②魔术方法

##### Ⅰ魔术方法一览表
+ 类中的内置方法被称之为魔术方法

|方法名|描述|
|---|---|
|`__init__`|类的**构造方法**，支持传入参数|
|`__str__`|自定义类对象输出时输出对应字符串而不是内存地址|
|`__lt__`|自定义类对象的'<'号和'>'号的比较|
|`__le__`|自定义类对象的'>='和'<='的比较|
|`__eq__`|自定义类类对象'=='比较|

---

##### Ⅱ具体样例

~~~python
  class Student:
      # 有参构造方法
      def __init__(self, name, age, location):
          self.name = name
          self.age = age
          self.location = location
          print("有参构造方法")

      def __str__(self):
          return f"名字为{self.name}，年龄是{self.age}，老家在{self.location}"

      def __lt__(self, other):
          return self.age < other.age

      # 如果不写该方法会报错
      def __le__(self, other):
          return self.age <= other.age

      # 如果不写该方法，默认比较两对象的地址
      def __eq__(self, other):
          return self.age == other.age


  student1 = Student("李四", 20, '河北省')
  student2 = Student("张三", 46, "山西省")
  print(student1, student1 > student2, student1 <= student2, student1 == student2)
~~~

### （三）封装

#### ①解释

+ 封装表示的是将现实世界中的属性和行为封装到类中，描述为成员变量和方法，从而完成程序对现实世界中事务的描述
+ 私有变量通过在前面写两个`_`来定义，私有方法也通过在前面写两个`_`来定义
+ 私有变量和私有方法**不能被类对象直接调用，但可以被类内部调用**

---

#### ②样例

~~~python
  class Phone:
      __5g = False  # 定义私有变量，类对象无法访问，但在类中可以访问

      def __init__(self, length, width):
          self.length = length
          self.width = width

      # 定义私有方法，类对象无法访问，但在类中可以访问
      def __judge(self):
          if self.__5g:
              print("可以使用5g网络")
          else:
              print("无法使用5g网络")

      def open_phone(self):
          print("开机")
          print("判断是否能使用5G网络")
          self.__judge()


  phone = Phone(50, 40)
  phone.open_phone()
  phone.__judge()  # 该情况会报错

~~~

---

## 二、继承

### （一）类的继承

+ 格式:`class 类(父类1,父类2,...):`
+ 在`Python`中，一个类可以有多个父类，如果这些父类中有的属性重名的话，依据**从左到右的先后顺序**来确定继承哪个类中的属性，如果父类中有方法重名的话，也是按上述顺序确定
+ 样例:
~~~python
  class class1:
      attribute1 = None
      attribute2 = True

      def print1(self):
          print("这是类1的方法")


  class class2:
      attribute1 = True
      attribute3 = 4.52

      def print2(self):
          print("这是类2的方法")


  class class3:
      attribute4 = ["aaa", 52]

      def print1(self):
          print("测试")

      def print3(self):
          print("这是类3的方法")


  class son_class(class1, class2, class3):
      pass  
      """
      在`Python`中，pass是一个空语句，它什么都不做。pass通常用作占位符，表示某个代码块暂时不需要执行任何操作，但为了保持语法的完整性，需要用一条语句占据位置。
      pass一般用于空的类和方法中
      """


  son = son_class()
  print(son.attribute1, son.attribute2, son.attribute3, son.attribute4)
  son.print1()
  son.print2()
  son.print3()

~~~

---

### （二）复写和调用

#### ①为什么要复写

+ 在`Python`中，如果子类认为父类的方法不够好，那么可以在子类里边定义一个与父类方法同名的方法，在此方法里面写入自己满意的操作，以此来达到部分目的

#### ②调用父类成员

+ 在子类中调用父类成员有两种办法
  1. `类名.变量名`和`类名.方法(self)`，调用方法时`self`是必须要传的，但可以精准的调用
  2. `super().变量名`和`super().方法`。该方法在对多个父类其中有重名变量和方法时只能根据**从左至右的顺序**选出第一个来访问或调用
+ **子类中无法使用父类的私有变量和私有方法**
+ 样例:
~~~python
  class class1:
      attribute1 = None
      attribute2 = True
      __test = 1

      def print1(self):
          print("这是类1的方法")

      def __test1(self):
          print("类1的私有方法")


  class class2:
      attribute1 = True
      attribute3 = 4.52

      def print2(self):
          print("这是类2的方法")


  class class3:
      attribute4 = ["aaa", 52]

      def print1(self):
          print("测试")

      def print3(self):
          print("这是类3的方法")


  class son_class(class1, class2, class3):
      def print2(self):
          print(f"输出一次类2的变量{class2.attribute3, class2.attribute1}")  # 利用 类名.变量名 的格式输出指定类的变量
          print(
              f"输出两次类2的变量{super().attribute1, super().attribute3}")  # 利用 super().变量名的格式输出，但如果继承多个父类，且父类的变量名有重复，使用该格式仅能返回根据类的次序从左至右找第一个有该属性的类的属性的值
          print("第一次调用类2方法")
          class2.print2(self)  # 利用 类名.方法名(self) 的格式调用指定类中的方法，使用该渠道调用方法需要传入self参数
          print(
              "第二次调用类2方法")  # 利用 super().方法名() 的格式调用指定类的方法，使用该渠道调用方法不需要传入self参数，但如果继承多个父类，且父类的方法名有重复，使用该格式仅能调用根据类的次序从左至右找第一个有该方法的类的
          super().print2()
          # 接下来是一些其它方面的补充
          # print(class1.__test) # 该方法会报错，说明子类无法直接调用父类的私有成员变量
          # class1.__test1(self)  # 该方法同样会报错，说明子类无法直接调用父类的私有方法


  son = son_class()
  print(son.attribute1, son.attribute2, son.attribute3, son.attribute4)
  son.print1()
  print("------")
  son.print2()
  print("------")
  son.print3()
  print("------")

  print(class1.attribute1)  # 在类外使用 类名.变量名 的格式也可以使用指定的类的成员变量，但不能访问私有成员变量
  class1.print1(self)  # 但在类外貌似不能使用 类名.方法(self) 的格式调用方法(编译器会报错)
~~~

---

## 三、类型注解

### （一）说明与注意事项

+ 类型注解可以向编译器和人提供更加明确、清晰的变量、方法等的类型提示，从而增加代码可读性
+ 类型注解并不是强制性的，即使变量所承载的数据类型与类型注解中提供的类型不一致，也不会报错，因为**类型注解是提示性的而非强制性**的
+ 对于嵌套的列表等，类型注解也可以进行详细的类型注解

<br>

### （二）变量类型注解

+ 其格式为:
  1. 格式`1`(在代码中进行):`变量:类型=值`
  2. 格式`2`(在注释中进行):`# type=类型`

+ 样例:
~~~python
  # 简单的类型注解
  a: int = 6
  b = 3.14  # type:float
  # 嵌套的类型注解
  c: list[str, float, bool] = ["aaa", 6.25, True]
  d = ["aaa", 6.25, True]  # type:list[str,float,bool]
  print(a, b,c,d)
~~~

<br>

### （三）方法/函数类型注解

+ 对函数或方法注解，可以对其形参类型和返回值类型注解
+ 格式为
~~~python
def 函数名(形参1:类型,形参2:类型,...)->返回值类型:
  函数体
~~~
+ 样例:
~~~python
  def function(a: int, b: int) -> str:
      return a + b  #返回值与返回值类型不一致同样不会报错


  print(function(1.25, 2.36))  #即使传入的数据与注解的类型不符，依然不会报错，因为注解并非强制性的

~~~

<br>

### （四）Union联合类型注解

+ 因为数据容器可以存放多种不同类型的数据，当各种数据类型杂糅在一起时，需要使用`Union`来进行联合类型注解
+ 格式为`Union[数据类型1,数据类型2,...]`
+ `Union`中包括的数据类型即为数据容器中所出现的全部数据类型
+ 样例:
~~~python
  from typing import Union

  a: dict[str, Union[list[Union[int, float]], bool]] = {"张三": [1, 20, 8.63], "李四": True}


  def function(a: int, b: float) -> list[Union[int, float]]:
      return [a, b]
~~~

---

## 四、多态

+ 多态指同一个行为通过不同的对象获得不同的状态
+ 样例:
~~~python
  """
  Animal类的作用在于，定义一个空的speak方法来确定Animal的标准，即只要是动物都会叫(speak)
  而不同的动物叫声不同，因此具体的动物子类在继承了Animal类后，根据自己的叫声重写speak方法，从而使每一种动物的叫声状态都不一致，也因此在将不同的动物对象传入animal_speak函数后得到的结果不同
  Animal类一般被称为抽象类(或接口)
  """
  class Animal:
      def speak(self):
          pass


  class Dog(Animal):
      def speak(self):
          print("汪汪")


  class Cat(Animal):
      def speak(self):
          print("喵喵")

  # 同一个行为
  def animal_speak(animal: Animal):
      animal.speak()


  dog = Dog()
  cat = Cat()
  animal_speak(dog) # 传入不同的对象，得到不同的状态
  animal_speak(cat) # 传入不同的对象，得到不同的状态

~~~

---

# 第四部分：模块

## 一、模块基础

### （一）模块的概念

> 模块(`Module`),是一个`Python`文件，以`.py`结尾。模块能定义函数、类和变量，模块里也能执行可执行的代码
+ `Python`中有很多不同的模块，这些模块是`Python`内置的，每一个模块都可以快速帮我们实现一些特定的功能

---

### （二）模块的导入

+ 格式:`[from 模块名] import [模块 | 类 | 变量 | 函数 | *] [as 别名]`
+ 上述格式被"[]"包起来的部分表示这些部分可以写也可以不写
+ 导入的常用组合类型包括
  + `import` 模块名
  + `from` 模块名 `import` 类、变量、方法等
  + `from` 模块名 `import` *
  + `import` 模块名 `as` 别名
  + `from` 模块名 `import` 功能名 `as` 别名
+ 样例：
~~~python
  import time  #导入time模块
  print("他好")
  time.sleep(1) #若以此方式导入，需要根据模块.函数()的方式调用模块中的函数
  print("我也好")

  from time import sleep  #导入time模块的sleep函数
  print("他好")
  sleep(1)  #以此方式导入，可以直接调用函数
  print("我也好")

  from time import *  #*号与第一种导入方式相同，也是将time模块的全部内容导入进来
  print("他好")
  sleep(1)  #与第一种方式不同的是，使用‘*’号导入可以直接调用函数
  print("我也好")


  from time import sleep as sl  #导入time模块的sleep函数并将此函数重新命名为sl
  print("他好")
  sl(1)
  print("我也好")


  import time as t  #导入time模块并将此模块命名为t
  print("他好")
  t.sleep(1)
  print("我也好")
~~~

---

### （三）自定义模块和导入

#### ①定义和导入格式

+ 自定义模块只需要创建一个`Python`文件，然后写上自己想写的代码即可
+ 导入自定义模块只需使用上文提到的`from import as`语法即可
+ 样例:
~~~python
  #my_module_one中的代码:
  def test(x,y):
      return x+y
  

  #my_module_two中的代码:
  def test(x,y):
    return x-y

  #要导入自定义模块的`Python`文件的代码
  import my_module_one
  result = my_module_one.test(1,2)
  print(result)


  from my_module_one import test
  from my_module_two import test  #如果导入了是不同模块的相同名称的函数，那么下面的会将上面的覆盖
  result = test(1,2)
  print(result)

~~~

---

#### ②__main__变量与__all__变量

~~~python
  # my_module_one中的代码:
  def test(x,y):
      return x+y
  print(test(1,2))

  #要导入自定义模块的`Python`文件的代码
  import my_module_one
  result = my_module_one.test(1,2)
  print(result)
  # 根据执行的结果来看，程序会输出两个结果，但此代码中仅让输出一个结果
  # 这是因为在import时，程序会将import的模块运行一遍，因此在运行到my_module_one代码的print时，便输出了
  # 要规避这一问题，需要用到__main__变量

  #修改后的my_module_one代码:
  def test(x,y):
    return x+y
  # __name__是`Python`内置的一个变量，该变量在程序运行时的值为'__main__'，因此使用一个if语句便可以使下方的代码始终为真。而当模块被调用时，该变量的结果不会是'__main__'，所以if语句内的代码不会被执行
  if __name__ == '__main__':
    print(test(1,2))
~~~


~~~python
  def test1(x,y):
    return x+y
  print(test(1,2))
  def test2(x,y):
    return x-y

  #要导入自定义模块的`Python`文件的代码
  from my_module_one import *
  print(test1(1,2),test2(1,2))
  #此时函数test1与函数test2都可以正常使用

  #修改后的my_module_one代码:
  __all__=['test1']
  def test1(x, y):
    return x + y
  def test2(x, y):
    return x - y
  # __all__是`Python`中的一个内置变量，如果有`Python`文件在导入此模块时使用的是 from 模块 import *的格式的话，那么该导入方式是根据__all__中的值来读取内容的，如果在该变量上加以限制，那么即使写了‘*’号也无法将该模块中的内容全部导入，而是只会导入该变量中存在的内容
  # 给__all__赋值并不能限制 import 模块 这种格式导入模块的全部内容,也不能限制 from 模块 import 内容 这种指定了内容的导入方式
~~~


---

### （四）包

#### ①认识包

+ 从物理上看，包是可以承载多个模块文件的文件夹
+ 从逻辑上看，**包的本质是模块**

---

#### ②包的定义

+ 在`Pycharm`新建一个`Python`包即可，或新建一个文件夹，在文件夹中新建一个名字叫 `__init__py` 的`Python`文件
+ `Python`包与文件夹的区别在于`Python`包中有一个名字叫 `__init__py` 的`Python`文件,如果没有此文件，那么`Python`包会成为文件夹

---

#### ③导入自定义包

+ 样例:
~~~python
    #包的导入方式与模块的导入方式是一致的，
    from my_package.my_module_one import *
    from my_package.my_module_two import *
    from my_package import my_module_one,my_module_two
    my_module_one.function1()
    my_module_two.function2()

    #使用__init__文件和__all__变量限制‘*’导入包
    from my_package import *
    my_module_one.function1()
    my_module_two.function2()

    #__init__文件中的代码:
    __all__=['my_module_one','my_module_two']  #与直接导入模块不同的是，如果不写的话，什么都导入不了
~~~

---

#### ④导入第三方包

###### <一>概述

+ 第三方包并非`Python`自己提供，而是由第三方开发人员提供，**需要自行下载导入**
+ 导入方式:
  1. 使用`pip`下载导入
  2. 使用`Pycharm`导入

---

###### <二>pip使用指南

|操作|描述|备注|
|:---:|:---:|:---:|
|`install`|安装第三方包|使用`pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 要下载的包`来连接清华的国内开源站进行下载|
|`uninstall`|卸载第三方包|无|
|`list`|列出目前安装的包|无|

+ 如果显示没有命令`pip`,在自己的`python`文件夹中找到其根目录下的`scripts`文件夹，并将该地址添加到环境变量中,或者使用`python -m pip ...`的方式调用
+ 如果`Pycharm`中找不到`pip`下载的包:
  1. 在`python`程序中导入`sys`(`import sys`),并输出`sys.path`(`print(sys.path)`(该属性是通过列表形式输出的))查看python解释器的检索包的路径,如果没有可以选择`sys.path.append(路径)`来将包所在的路径添加到`path`中，也可以将包移动到`sys.path`中包含的路径中
  2. 查看`Pycharm`中的`Python`解释器是否为本地的解释器或者是`Pycharm`自己在项目里下载的解释器，使用`pip`下载的第三方库一般都会被导入到本地的文件夹，而此时`Pycharm`自己项目里下载的解释器会访问不到，可以手动添加本地目录的解释器


###### <三>pip导入流程

1. `Windows+r`后输入`cmd`打开命令提示符
2. 在写入如下语句:`pip install 要下载的包`
3. 等待下载完成，下载完成后命令提示符界面会出现`successfully`

+ **不建议**这样下载，因为这样下载会很慢，原因是`Python`的`pip`在下载包时会自动连接国外的网站，因此下载速度会慢。
以下是一些优化方法:
+ 使用一些国内的开源镜像站来下载资源，比如[清华大学的开源镜像站](https://mirrors.tuna.tsinghua.edu.cn/)
+ 在命令提示符内输入`pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 要下载的包`即可
+ 详情参考[清华大学开源软件镜像站PyPI镜像使用帮助](https://mirrors.tuna.tsinghua.edu.cn/help/pypi/)

---

###### <四>Pycharm导入流程

1. 打开`Pycharm`，点击右下角的解释器版本，然后点击解释器设置
2. 在弹出的界面点击中央偏上的“`Python`解释器”下方的‘+’号按钮
3. 输入要下载的包并选择，此时`Pycharm`依然使用国外网站进行中下载，点击右下角的“选项”，输入`-i https://pypi.tuna.tsinghua.edu.cn/simple`设置下载网站
4. 点击下方的安装软件包，等到下载和安装完成

---

## 二、可视化案例

+ 详情参考[pyecharts使用文档](https://05x-docs.pyecharts.org/#/zh-cn/)

### （一）json数据格式转换

#### ①概念

> `Json`是一种轻量级的数据交互格式，可以按照`Json`指定的格式去组织和封装数据
+ `json`是一种在各个编程语言中流通的数据格式，负责不同语言中的数据传递和递交
+ `Json`本质上是一个**带有特定格式的字符串**

#### ②格式

|操作分类|操作/方法 名称|格式|说明|备注|返回类型|返回值|
|---|---|---|---|---|---|---|
|`json`类型转换|`dumps`|`json.dumps(待转换对象,ensure_ascii=True/False)`|将`Python`数据转换为`json`|无|`str`|转换后的数据|
|^|`loads`|`json.loads(待转换对象)`|将`json`转换为对应`Python`数据|无|`list/dict`|转换后的数据|

+ 在`Python`中，不需要太多的去了解`json`的格式，可以简要的了解其大体格式:
~~~python
  import json

  # 格式一
  json1={
      "张三":"学生",
      "李四":"教师",
      "王五":"快递员",
      "赵六":"程序员"
      }  #该格式即`Python`的字典

  #json格式2
  json2=[{"张三":20},{"李四":28},{"王五":16}]  #该格式是元素为字典的列表，要求是列表里只能有字典

  #  列表和字典转json
  result1=json.dumps(json1,ensure_ascii=False)
  result2=json.dumps(json2,ensure_ascii=False)
  print(f"类型是{type(result1),type(result2)}，值为{result1,result2}")

  #  json转`Python`数据
  json1=json.loads(result1)
  json2=json.loads(result2)
  print(f"类型是{type(json1),type(json2)}，值为{json1,json2}")
~~~

---

### （二）pyecharts模块的使用

#### ①折线图

##### Ⅰ操作示例

~~~python
  import json
  from pyecharts.charts import Line  # 导入Line类，该类可以生成折线图对象
  from pyecharts.options import TitleOpts, LabelOpts, ToolboxOpts, TooltipOpts  # 导入其它属性类

  usa_file = open("E:\Programming Language\python\pythonProject\资料\可视化案例数据\折线图数据\美国.json", "r",
                  encoding="UTF-8")
  jap_file = open("E:\Programming Language\python\pythonProject\资料\可视化案例数据\折线图数据\日本.json", "r",
                  encoding="UTF-8")
  ida_file = open("E:\Programming Language\python\pythonProject\资料\可视化案例数据\折线图数据\印度.json", "r",
                  encoding="UTF-8")

  usa_file = json.loads(usa_file.read())
  jap_file = json.loads(jap_file.read())
  ida_file = json.loads(ida_file.read())

  usa_file = usa_file['data'][0]['trend']
  usa_file_date = usa_file['updateDate'][:314]
  usa_file_data = usa_file['list'][0]['data'][:314]

  jap_file = jap_file['data'][0]['trend']
  jap_file_date = jap_file['updateDate'][:314]
  jap_file_data = jap_file['list'][0]['data'][:314]

  ida_file = ida_file['data'][0]['trend']
  ida_file_date = ida_file['updateDate'][:314]
  ida_file_data = ida_file['list'][0]['data'][:314]

  line = Line()
  line.add_xaxis(usa_file_date)
  # 第一个传入的参数为线条表示的意义，第二个参数为x对应的y轴坐标，第三个为设置坐标值不可见
  # x和y的坐标值格式应该为列表
  line.add_yaxis("美国确诊病例", usa_file_data, label_opts=LabelOpts(is_show=False))
  line.add_yaxis("日本确诊病例", jap_file_data, label_opts=LabelOpts(is_show=False))
  line.add_yaxis("印度确诊病例", ida_file_data, label_opts=LabelOpts(is_show=False))
  line.set_global_opts(
      # 设置标题的题目和位置
      title_opts=TitleOpts(title="美日印三国疫情确诊折线图", pos_left="center", pos_bottom="1%"),
      # 设置工具栏可见
      toolbox_opts=ToolboxOpts(is_show=True),
      # 设置提示框组件可见
      tooltip_opts=TooltipOpts(is_show=True)
  )
  line.render()


~~~

---

#### ②地图

##### Ⅰ简单示例

~~~python
  from pyecharts.charts import Map  #导入map类
  from pyecharts.options import VisualMapOpts  #导入VisualMapOpts类
  map = Map()
  # 数据必须为列表嵌套元组的格式
  data=[
      ("河北省",8),
      ("广东省",52),
      ("北京省",33),
      ("新疆省",12),
      ("西藏省",4),
      ("台湾省",48),
      ("湖南省",30),
      ("湖北省",32),
      ("江苏省",49)
  ]
  # 设置地图名称、添加数据、设置地图样式
  map.add("测试地图",data,"china")
  map.set_global_opts(
      visualmap_opts=VisualMapOpts(
          is_show=True,  # 设置视觉映射可见
          is_piecewise=True,  # 设置可自定义更改视觉映射
          # 自定义视觉映射，格式为列表嵌套字典
          pieces=[
            # 设置范围最小值、最大值、指示范围标签值、范围颜色
              {"min": 1, "max": 9, "label": "1-9", "color": "#b9e2ef"},
              {"min": 10, "max": 19, "label": "10-19", "color": "#b9efcd"},
              {"min": 20, "max": 29, "label": "20-29", "color": "#deefb9"},
              {"min": 30, "max": 39, "label": "30-39", "color": "#efe5b9"},
              {"min": 40, "max": 49, "label": "40-49", "color": "#efcbb9"},
              {"min": 50, "max": 59, "label": "50-59", "color": "#e7807e"},
              {"min": 60, "max": 59, "label": "60-69", "color": "#d0332f"},
          ]
      )
  )
  map.render()  # 生成地图
~~~

---

##### Ⅱ全国疫情省份确诊地图

~~~python
  import json

  from pyecharts.charts import Map
  from pyecharts.options import TitleOpts,VisualMapOpts,LabelOpts

  map_province_data=[]
  with open("E:/`Python`/`Python`Project/资料/可视化案例数据/地图数据/疫情.json","r",encoding="UTF-8") as file:
      province_data=json.loads(file.read())
      province_data=province_data['areaTree'][0]['children']
      for i in province_data:
          map_province_data.append((i["name"],i["total"]['confirm']))
  map=Map()
  map.add("全国疫情省份地图",map_province_data,"china",label_opts=LabelOpts(is_show=False))
  map.set_global_opts(
      title_opts=TitleOpts(title="疫情地图"),
      visualmap_opts=VisualMapOpts(
          is_show=True,
          is_piecewise=True,
          pieces=[
              {"min":1,"max":9,"label":"1-9人","color":"#CCFFFF"},
              {"min":10,"max":99,"label":"10-99人","color":"#FFFF99"},
              {"min":100,"max":999,"label":"100-999人","color":"#FF9966"},
              {"min":1000,"max":9999,"label":"1000-9999人","color":"#FF6666"},
              {"min":10000,"max":99999,"label":"10000-99999人","color":"#CC3333"},
              {"min":100000,"label":"1-9人","color":"#990033"}
          ]
      )
  )
  map.render()
~~~

---

#### ③柱状图

##### Ⅰ构建基本柱状图

~~~python
  from pyecharts.charts import Bar  #导入Bar类，该类可以创建柱状图对象
  from pyecharts.options import LabelOpts
  bar = Bar()
  bar.add_xaxis(['张三','李四','王五'])
  bar.add_yaxis("身高",[1.72,1.66,1.81],label_opts=LabelOpts(position="right")) # 传入y轴坐标并令数据显示在右侧
  bar.reversal_axis()  # 柱状图x、y轴反转
  bar.render()
~~~

---

##### Ⅱ基础时间线柱状图构建

~~~python
  from pyecharts.charts import Bar, Timeline
  from pyecharts.options import LabelOpts
  from pyecharts.globals import ThemeType

  timeline = Timeline({"theme": ThemeType.LIGHT})  #设置主题，具体作用于柱状图的柱的颜色

  bar1 = Bar()
  bar1.add_xaxis(['张三', '李四', '王五'])
  bar1.add_yaxis("身高", [1.20, 1.22, 1.17], label_opts=LabelOpts(position="right"))
  bar1.reversal_axis()

  bar2 = Bar()
  bar2.add_xaxis(['张三', '李四', '王五'])
  bar2.add_yaxis("身高", [1.53, 1.41, 1.50], label_opts=LabelOpts(position="right"))
  bar2.reversal_axis()

  bar3 = Bar()
  bar3.add_xaxis(['张三', '李四', '王五'])
  bar3.add_yaxis("身高", [1.72, 1.66, 1.81], label_opts=LabelOpts(position="right"))
  bar3.reversal_axis()

  timeline.add(bar1, "10岁")  #将各柱状图对象加入时间线，并写上时间线对应下标
  timeline.add(bar2, "15岁")
  timeline.add(bar3, "20岁")

  #设置时间线播放要求
  timeline.add_schema(
      play_interval=1000,  # 每隔1000ms柱状图轮换一次
      is_timeline_show=True,  # 显示时间线
      is_auto_play=False,  # 设置不自动播放
      is_loop_play=False  # 设置不循环播放
  )

  timeline.render()  # 如果有时间线，需要用时间线对象生成图表

~~~

---

##### Ⅲ动态GDP柱状图绘制

~~~python
  # 方法一(自己写的):

  from pyecharts.charts import Bar, Timeline
  from pyecharts.globals import ThemeType
  from pyecharts.options import LabelOpts

  list1 = []
  list2 = []
  x_data = []
  y_data = []
  year = 1960
  timeline = Timeline({"theme": ThemeType.LIGHT})
  with open("E:\\`Python`\\`Python`Project\\资料\\可视化案例数据\\动态柱状图数据\\1960-2019全球GDP数据.csv", "r",encoding="ANSI") as file:
      for i in file:
          split_result = i.split(",")
          if int(split_result[0]) == year:
              list1.append([split_result[1], float(split_result[2].strip())/100000000])
          else:
              bar = Bar()
              list1.sort(key=lambda element: element[1], reverse=True)
              list1 = list1[:8]
              for j in range(8):
                  x_data.append(list1[j][0])
                  y_data.append(list1[j][1])
              x_data.reverse()
              y_data.reverse()
              bar.add_xaxis(x_data)
              bar.add_yaxis("各国GDP总值(单位：亿)", y_data, label_opts=LabelOpts(position="right"))
              bar.reversal_axis()
              timeline.add(bar, str(year))
              year += 1
              list1.clear()
              list1.append([split_result[1], float(split_result[2].strip())/100000000])
              x_data=[]
              y_data=[]
  timeline.add_schema(
      is_auto_play=True,
      is_loop_play=False,
      play_interval=500,
      is_timeline_show=True
  )
  timeline.render()



  # 方法二(课程代码):

  from pyecharts.charts import Bar, Timeline
  from pyecharts.options import *
  from pyecharts.globals import ThemeType

  # 读取数据
  f = open("e:\\`Python`\\`Python`Project\\资料\\可视化案例数据\\动态柱状图数据\\1960-2019全球GDP数据.csv", "r", encoding="GB2312")
  data_lines = f.readlines()
  # 关闭文件
  f.close()
  # 将数据转换为字典存储，格式为：
  # { 年份: [ [国家, gdp], [国家,gdp], ......  ], 年份: [ [国家, gdp], [国家,gdp], ......  ], ...... }
  # { 1960: [ [美国, 123], [中国,321], ......  ], 1961: [ [美国, 123], [中国,321], ......  ], ...... }
  # 先定义一个字典对象
  data_dict = {}
  for line in data_lines:
      year = int(line.split(",")[0])      # 年份
      country = line.split(",")[1]        # 国家
      gdp = float(line.split(",")[2])     # gdp数据
      # 如何判断字典里面有没有指定的key呢？
      # 妈的，想死我也想不出来这方法
      try:
          data_dict[year].append([country, gdp])
      except KeyError:
          data_dict[year] = []
          data_dict[year].append([country, gdp])

  # print(data_dict[1960])
  # 创建时间线对象
  timeline = Timeline({"theme": ThemeType.LIGHT})
  # 排序年份
  sorted_year_list = sorted(data_dict.keys())
  for year in sorted_year_list:
      data_dict[year].sort(key=lambda element: element[1], reverse=True)
      # 取出本年份前8名的国家
      year_data = data_dict[year][0:8]
      x_data = []
      y_data = []
      for country_gdp in year_data:
          x_data.append(country_gdp[0])   # x轴添加国家
          y_data.append(country_gdp[1] / 100000000)   # y轴添加gdp数据

      # 构建柱状图
      bar = Bar()
      x_data.reverse()
      y_data.reverse()
      bar.add_xaxis(x_data)
      bar.add_yaxis("GDP(亿)", y_data, label_opts=LabelOpts(position="right"))
      # 反转x轴和y轴
      bar.reversal_axis()
      # 设置每一年的图表的标题
      bar.set_global_opts(
          title_opts=TitleOpts(title=f"{year}年全球前8GDP数据")
      )
      timeline.add(bar, str(year))


  # for循环每一年的数据，基于每一年的数据，创建每一年的bar对象
  # 在for中，将每一年的bar对象添加到时间线中

  # 设置时间线自动播放
  timeline.add_schema(
      play_interval=1000,
      is_timeline_show=True,
      is_auto_play=True,
      is_loop_play=False
  )
  # 绘图
  timeline.render("1960-2019全球GDP前8国家.html")  #绘制图表并自定义生成的文件名称

~~~

---

## 三、Mysql数据库操作

~~~python
  # 进行连接数据库的操作需要导入第三方包pymysql
  from pymysql import Connect

  conn = Connect(
      host="localhost",  # 主机名(IP)
      port=3306,  # 端口
      user="root",  # 数据库账户
      password="yyy",  # 数据库密码,yyy对应的是密码，使用时修改为对应真实密码
      autocommit=False # 设置是否对数据库修改后自动确认，设置True后，即使不写确认代码，执行excute函数后会直接修改数据库
  )
  cursor = conn.cursor()  # 获取游标对象(指针)
  conn.select_db("course")  # 选择数据库
  cursor.execute("select * from course") # 数据库查询操作，对数据库本身无修改
  result: tuple = cursor.fetchall()  # 将得到的查询结果以元组的形式返回
  for i in result:
      print(i)

  # 以下是对数据库的修改操作，当执行该操作时，修改结果并不会直接反应在数据库上，需要使用代码确认后才能真正修改，类似于编辑文本时需要按保存才会保存对文本的修改
  cursor.execute("insert into course values('10007','`Python`','3.00')")
  cursor.execute("delete from course where Cno='10007'")
  cursor.execute("update course set Cname='Java语言程序设计' where Cno='10005'")

  conn.commit()  # 改代码用于确认对数据库的修改操作
  conn.close() # 解除与数据库的连接
~~~

---

## 四、PySpark模块使用

### （一）初始化对象

~~~python
  from pyspark import SparkConf, SparkContext

  conf = SparkConf().setMaster("local[*]").setAppName("test")  # 创建SparkConf类对象
  """
      上述方法为链式调用，与
      conf=SparkConf()
      conf.setMaster("local[*]")
      conf.setAppName("test")
      三句代码得到的结果是一样的，需要注意，三句代码的返回值全都是SparkConf类对象
  """
  sc = SparkContext(conf=conf)  # 创建SparkContext对象
  print(sc.version)  # 打印Spark版本
  sc.stop()  # 停止对象运行
  # 需要注意的是，如果没有handoop库的话，它会默认使用Java内置类，因此该模块需要Java的运行环境
~~~

<br>

### （二）数据输入与输出

#### ①方法一览表

|方法名|格式|描述|返回类型|备注|依赖|
|---|---|---|---|---|---|
|`parallelize`|`SparkContext对象.parallelize(待转换数据)`|将传入的数据转换成`RDD`对象|`pyspark.rdd.RDD`|传入字符串时，将字符串的每个字符作为一个元素；传入字典时，仅保留字典的`key`，不保留`value`|`pyspark`模块的`SparkContext`类|
|`collect`|`rdd对象.collect()`|将`rdd`对象转化为列表|`list`|无|不明|
|`textfile`|`rdd对象.textfile(参数)`|将文件中的数据转换为`RDD`对象|^|无|^|

<br>

#### ②数据输入

+ 样例:
~~~python
  from pyspark import SparkContext, SparkConf

  conf = SparkConf().setMaster("local[*]").setAppName('conf')
  sc = SparkContext(conf=conf)
  # 使用parallelize方法将数据容器转换为RDD对象
  rdd1 = sc.parallelize([1, 2, 3, 4, 5])
  rdd2 = sc.parallelize((1, 2, 3, 4, 5))
  rdd3 = sc.parallelize("awGEYwe")
  rdd4 = sc.parallelize({5, 7, 9, 6})
  rdd5 = sc.parallelize({"aaa": 1, "n": 2})
  # 使用textFile方法将文件数据转换为RDD对象
  rdd_file = sc.textFile("E:\\`Python`\\`Python`Project\\资料\\PySpark\\test.txt")
  # 使用collect和print输出RDD对象的数据
  print(rdd1.collect())
  print(rdd2.collect())
  print(rdd3.collect())
  print(rdd4.collect())
  print(rdd5.collect())
  print(rdd_file.collect())
  sc.stop()

~~~

#### ③数据计算

+ 待施工

---

## 五、math模块

+ `math`模块中具有许多的数学函数(不支持复数运算),可以为数学计算提供很大的帮助

### （一）函数表

|函数名|格式|描述|备注|返回类型|返回值|
|:---:|:---:|:---:|:---:|:---:|:---:|
|`factorial`|`math.factorial(number)`|对整数进行阶乘运算|**参数必须为非负整数**|`int`|阶乘结果|
|`prod`|`math.prod(iterable,*,start=1)`|计算输入的可迭代对象中所有元素的积|1.积的默认起始值`start`值为`1`，且`start`参数**传参需要使用关键字传参** <br> 2.该函数仅能处理数字值|`number`|所有元素的积|
|`fabs`|`math.fabs(arg)`|以浮点数形式返回参数的绝对值|无|`float`|绝对值|
|`sqrt`|`math.sqrt(number)`|返回参数的平方根|无|`number`|平方根|
|`isqrt`|`math.isqrt(n)`|返回非负整数n的整数平方根|1.即返回`n>=a^2`的a的取值范围中的最大整数<br>2.传入的参数必须为非负整数|`number`|整数平方根|
|`pow`|`math.pow(x,y)`|返回(`x^y`)|无|`float`|`x^y`|
|`pi`|`math.pi`|返回圆周率`Π`的值|无|`float`|`Π`|
|`sin`|`math.sin(x)`|返回`x`的正弦值|`x`为弧度值，弧度公式为`n*Π/180`|`float`|`x`的正弦值|
|`cos`|`math.cos(x)`|返回`x`的余弦值|`x`为弧度值，弧度公式为`n*Π/180`|`float`|`x`的余弦值|
|`degrees`|`math.degrees(x)`|弧度值转角度值|无|`number`|转换后的角度值|
|`radians`|`math.radians(x)`|角度值转弧度值|无|`number`|转换后的弧度值|
|`fsum`|`math.fsum()`|返回浮点数迭代求和的精确值|该函数可以避免多次求和导致的精度缺失|`float`|多个数的和|
|`hypot`|`math.htpot(x,y)`|返回坐标`(x,y)`到坐标原点的距离|无|`number`|坐标`(x,y)`到坐标原点的距离|
|`log`|`math.log(x,base)`|返回以`base`为底的`x`的对数|若不写`base`，默认为自然对数`e`|`number`|以`base`为底的`x`的对数|
|`log2`|`math.log2(x)`|计算以`2`为底的`x`的对数|使用该函数计算的值通常比`math.log(x,2)`计算出的值更精确|`number`|以`2`为底的`x`的对数|
|`log10`|`math.log10(x)`|计算以`10`为底的`x`的对数|使用该函数计算的值通常比`math.log(x,10)`计算出的值更精确|`number`|以`10`为底的`x`的对数|
|`e`|`math.e`|返回自然常数`e`的值|无|`float`|自然常数`e`|
|`exp`|`math.exp(x)`|返回`e^x`|无|`float`|`e^x`|
|`dist`|`math.dist(p,q)`|返回`p`与`q`之间的欧几里得距离|无|`number`|`p`与`q`之间的欧几里得距离|
|`comb`|`math.comb(n,k)`|返回不重复且无顺序的从`n`项中选择`k`项的方式总数,即**二项式系数**|当`k>n`时值为`0`，当`k<=n`时值为`n!`|`int`|二项式系数|
|`floor`|`math.floor(x)`|返回不大于`x`的最大整数|无|`int`|不大于`x`的最大整数|
|`ceil`|`math.ceil(x)`|返回不小于`x`的最小整数|无|`int`|不小于`x`的最小整数|
|`gcd`|`math.gcd(*integers)`|返回给定整数参数的最大公约数|无|`int`|1.如果参数至少有一个非`0`，则返回值为能够同时整除所有参数的最大正整数<br>2.如果所有参数为`0`或无参数，则返回`0`|
|`lcm`|`math.lcm(*integers)`|返回给定整数参数的最小公倍数|无|`int`|1.如果参数所有参数均非`0`，则返回值为所有参数的整数倍的最小正整数<br>2.如果参数之一为`0`，则返回`0`|

---

### （二）函数详解

+ 待施工

---

# 第五部分：杂项

## 一、闭包

### （一）闭包示例

+ 如果在`Python`程序中直接定义了全局变量来进行数据操作的话，该变量容易因其他原因被修改，因此需要使用闭包来提高其数据安全性
+ 示例
~~~python
  def create_account(initial_amount=0):
      # 在函数内部，也可以定义函数，并将其作为返回值返回
      # 存钱函数
      def deposit(money: int):
          nonlocal initial_amount  # nonlocal关键字可以使嵌套函数内部的函数修改外部函数的变量值
          if money > 0:
              initial_amount += money
              print(f"存入{money}元，余额为{initial_amount}元")
          else:
              print("输入的数据不合法")

      # 取钱函数
      def get_money(money: int):
          nonlocal initial_amount
          if 0 < money <= initial_amount:
              initial_amount -= money
              print(f"取出{money}元，还剩下{initial_amount}元")
          else:
              print("输入的数据不合法")

      # 查看账户余额函数
      def look_account():
          print(f"余额为{initial_amount}元")

      # 更改余额函数
      def change_initial_money(money: int):
          nonlocal initial_amount
          if money >= 0:
              initial_amount = money
              print(f"修改余额为{initial_amount}元")
          else:
              print("输入的数据不合法")

      # 函数可以返回其内部定义的函数对象
      return deposit, get_money, look_account, change_initial_money


  # 使用四个变量接收四个函数返回值
  deposit, get_money, look_account, change_initial_money = create_account()
  deposit(50)
  get_money(20)
  look_account()
  change_initial_money(100)

~~~

<br>

### （二）闭包的优缺点

+ 优点:
  1. 无需使用全局变量即**可通过函数持续访问、修改某个值**
  2. 闭包使用的变量**作用域在函数中**，难以被错误的调用更改
+ 缺点:
  1. 由于内部函数持续引用外部变量的值，所以会导致这一部分的**内存空间不被释放，一直占用内存**

---

## 二、装饰器

> 装饰器就是创建一个闭包函数，在闭包函数内调用目标函数
+ 装饰器可以达到**不改动目标函数功能的同时，增加额外的功能**
+ 示例:
~~~python
  def extra(function):
      def inner():
          print("在函数执行前显示这句话")
          function()
          print("在函数执行后显示这句话")

      return inner


  @extra  # 使用装饰器的快捷写法（语法糖）来快速调用装饰器
  def function():
      print("函数被执行了")


  function()  # 在快捷写法中，直接调用目标函数即可
  """
      这样的写法实现的过程为:
      1.将function函数作为参数传入到extra函数的参数中去
      2.执行extra函数内部的代码，并返回inner返回值
      3.执行inner函数
  """

~~~

---

## 三、多线程

### （一）线程的创建和运行

+ 线程的类初始化定义为(使用线程需要`import threading`文件):
+ `threading.Thread(self, group=None, target=None, name=None,args=(), kwargs=None, *, daemon=None)`
  1. `group`:暂时无用，未来功能的预留参数
  2. `target`:执行任务的目标名
  3. `name`:线程名称
  4. `args`:以元组形式传入任务所需参数
  5. `kwards`:以字典形式传入任务所需参数
+ 示例:
~~~python
  import threading
  import time


  def test1(target):
      while True:
          print(f"函数1执行,标记为{target}")
          time.sleep(1)


  def test2(target):
      while True:
          print(f"函数2执行,标记为{target}")
          time.sleep(1)


  thread1 = threading.Thread(target=test1, name="线程1", kwargs={"target": 1})
  thread2 = threading.Thread(target=test2, name="线程2", args=(2,))
  thread1.start()
  thread2.start()

~~~

+ 待施工

---

## 四、正则表达式

+ `Python`正则表达式方法及参数表

|方法|格式|描述|备注|依赖|
|---|---|---|---|---|
|`match`|`re.match(pattern, string, flags=0)`|从字符串的开头开始匹配模式。如果找到匹配项，则返回一个匹配对象；否则，返回`None`。|无|`import re`|
|`search`|`re.search(pattern, string, flags=0)`|在整个字符串中从前向后搜索匹配模式。如果找到匹配项，则返回一个匹配对象；否则，返回`None`。|找到第一个匹配对象后就会停止，不会继续向后|^|
|`findall`|`re.findall(pattern, string, flags=0)`|返回一个包含所有非重叠匹配的列表。每个列表包含的匹配项都是字符串。|如果全都没有匹配，返回一个空列表|^|
|`sub`|`re.sub(pattern, repl, string, count=0, flags=0)`|将字符串中与模式匹配的所有子串替换为指定的替换字符串。|无|^|
|`split`|`re.split(pattern, string, maxsplit=0, flags=0)`|根据匹配模式将字符串分割成列表。可以指定最大分割次数。|无|^|
|`subn`|`re.subn(pattern, repl, string, count=0, flags=0)`|类似于`re.sub()`，但返回一个元组，包含替换后的字符串和替换的次数。|无|^|
|`fullmatch`|`re.fullmatch(pattern, string, flags=0)`|判断整个字符串是否与模式完全匹配。如果匹配成功，则返回一个匹配对象；否则，返回`None`。|无|^|
|`escape`|`re.escape(string)`|对字符串中的特殊字符进行转义，使其在正则表达式中按字面意义匹配。|无|^|
|`compile`|`re.compile(pattern, flags=0)`|将正则表达式编译成模式对象，以便反复使用。模式对象可以调用其方法来执行匹配操作。|无|^|

|flags参数|替代|描述|
|---|---|---|
|`re.IGNORECASE`|`re.I`|忽略大小写进行匹配。|
|`re.MULTILINE`|`re.M`|将字符串视为多行，使`^`和`$`可以匹配每行的开头和结尾。|
|`re.DOTALL`|`re.S`|使`.`匹配任何字符，包括换行符。|
|`re.VERBOSE`|`re.X`|允许在正则表达式中使用注释和空白字符，增加可读性。|



