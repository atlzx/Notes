<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>JS_定时器本质</title>
    <script>
        onload=function(){
            // 定时器每3s将函数添加到消息队列中，但每个函数执行需要花费至少6s以上
            // 这样会导致第一个函数执行完，第二个函数会立即执行，而不是我们想的每个函数执行都相隔3s
            // 因此setInterval方法无法保证用户所见到的函数的执行时间间隔固定
            /*  setInterval(
                ()=>{
                    // alert是否执行完成取决于用户点击该警示框的速度，如果用户3s后才点
                    // 此时第二个函数已经进入了消息队列，且第一个函数执行完后调用栈空，第二个函数得以立即进入调用栈执行
                    // 因此下一个函数的alert方法也被被立即调用.这样就无法保证用户见到的函数执行时间间隔绝对固定
                    alert('计时器的执行');  
                },
                3000
            );  */
            setTimeout(
                function fn1(){
                    alert('计时器的执行');
                    setTimeout(fn1,3000);  // 使用递归的方法可有效地避免上述问题，因为每次都是上一个函数的功能全部执行完毕后才设置下一个定时器
                },
                3000
            );

            setTimeout(
                ()=>{
                    console.log(1111);
                },
                0
            );  // 设置该代码执行0s后将函数移到消息队列中去
            console.log(2222);  // 222会比111先显示，因为该行代码位于全局作用域，全局作用域位于调用栈中，调用栈执行完毕后消息队列中的函数才能进入调用栈执行
        }
    </script>
</head>
<body>
    
</body>
</html>